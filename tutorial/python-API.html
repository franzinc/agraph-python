<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>AllegroGraph Python API Reference</title>

<style type="text/css">

.input { margin-left:4em; background-color:#ADDFFF;}
.output { margin-left:4em; background-color:#F1F1F1;}
.returnlink {font-size:small;  font-weight:normal; }

</style>
</head>
<body>
<h1>AllegroGraph Python API Reference</h1>

<p>
Click <a href="../index.html">here</a> for general AllegroGraph
documentation.
</p>
<p>This is a description of the Python Application Programmer's Interface (API) to
<a href="http://agraph.franz.com/allegrograph/">Franz Inc.'s</a>
AllegroGraph RDFStore&#8482;</p>
<p>
The Python API offers convenient and efficient
access to an AllegroGraph server from a Python-based application.  This API provides methods for
creating, querying and maintaining RDF data, and for managing the stored triples. </p>
<table border="1">
    <tr>
        <td width="867">The Python API deliberately emulates the Aduna Sesame API to make it easier to migrate from Sesame to AllegroGraph.&nbsp; The Python API has also been extended in ways that make it easier and more intuitive than the Sesame API.</td>
    </tr>
</table>
<h2 id="Contents">Contents</h2>
<ul>
  <li><a href="#AllegroGraphServer Class">AllegroGraphServer Class</a></li>
  <li><a href="#Catalog Class">Catalog Class</a></li>
  <li><a href="#Repository Class">Repository Class</a></li>
  <li><a href="#RepositoryConnection Class">RepositoryConnection Class</a></li>
  <li><a href="#Query Class">Query Class</a>
    <ul>
      <li><a href="#Subclass TupleQuery">Subclass TupleQuery</a></li>
      <li><a href="#Subclass GraphQuery">Subclass GraphQuery</a></li>
      <li><a href="#Subclass BooleanQuery">Subclass BooleanQuery</a></li>
    </ul>
  </li>
  <li><a href="#QueryResult Class">QueryResult Class</a>
    <ul>
      <li><a href="#Subclass TupleQueryResult">Subclass TupleQueryResult</a></li>
      <li><a href="#Subclass GraphQueryResult">Subclass GraphQueryResult</a></li>
    </ul>
  </li>
  <li><a href="#RepositoryResult Class">RepositoryResult Class</a> </li>
  <li><a href="#Statement Class">Statement Class</a>  </li>
  <li><a href="#ValueFactory Class">ValueFactory Class</a></li>
</ul>
<h2 id="AllegroGraphServer Class">AllegroGraphServer Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The AllegroGraphServer  object represents a remote AllegroGraph server on the network.&nbsp; It is used to inventory and access the catalogs of that server.</p>
<p> Source: /AllegroGraphDirectory/src/franz/openrdf/sail/allegrographserver.py.</p>
<h3>Constructor</h3>
<p>AllegroGraphServer(self, host, port=10035,user=None,password=None)</p>
<ul>
  <li><em>host</em> is a string containing the IP address or hostname of the AllegroGraph server. No default. </li>
  <li><em>port</em> is the AllegroGraph HTTP port on the server. It is an integer that defaults to 10035.</li>
  <li><em>user</em> is an AllegroGraph user name.</li>
  <li><em>password</em> is the user's password.  </li>
  <li><em>proxy</em> Proxy specification string (optional). The format
    is SCHEME://HOST:PORT.  Supported schemes are 'http', 'socks4' and
    'socks5'.  'socks' can also be used as a synonym for
    'socks5'. Note that for SOCKS proxies DNS requests are performed
    by the proxy server.
  </li>
</ul>
<dl>
  <dt>Example:</dt>
</dl>
<pre>    server = AllegroGraphServer(host=&quot;localhost&quot;, port=8080, user=&quot;test&quot;, password=&quot;pw&quot;) </pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;"  >
  <tr>
    <td>getInitfile(self)</td>
    <td>Retrieve the contents of the server initialization file. </td>
  </tr>
  <tr>
      <td>listCatalogs(self)</td>
      <td>Returns a string containing the names of the server's catalogs. </td>
  </tr>
  <tr>
      <td>openCatalog(self, name=None)</td>
      <td>Returns a <a href="#Catalog Class">Catalog</a> object. <em>Name</em> is one of the catalog names from listCatalogs() or &quot;None&quot; to open the rootCatalog described in the AllegroGraph configuration file. </td>
  </tr>
  <tr>
    <td>openFederated(self, repositories, autocommit=False, lifetime=None, loadinitfile=False)</td>
    <td>Open a session that federates several repositories. The<br>
      <em>repositories</em> argument should be an array containing store<br>
designators, which can be Repository or RepositoryConnection 
objects, strings (naming a store in the root catalog, or the 
URL of a store), or (storename, catalogname) tuples.<br></td>
  </tr>
  <tr>
    <td>openSession(self,spec, autocommit=False, lifetime=None, loadinitfile=False)</td>
    <td>Open a session on a federated, reasoning, or filtered store.<br>
Use the helper functions in the franz.openrdf.sail.spec module 
to create the spec string.</td>
  </tr>
  <tr>
    <td>setInitfile(self, content=None, restart=True)</td>
    <td>Replace the current initialization file contents with the content string or remove if None. Restart specifies whether to shut down any current running back ends, so that subsequent requests will be handled by back ends that have loaded the new init file. </td>
  </tr>
  <tr>
    <td>url(self)</td>
    <td>Return the server's URL. </td>
  </tr>
  <tr>
    <td>version(self)</td>
    <td>Return the server's version as a string. </td>
  </tr>

</table>
<h2 id="Catalog Class">Catalog Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A Catalog object is a container for multiple repositories.&nbsp; </p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/sail/allegrographserver.py.</p>
<h3>Constructor</h3>
<p>Invoke the Catalog constructor using the <a href="#AllegroGraphServer Class">AllegroGraphServer</a>.openCatalog() method.</p>
<pre>    catalog = server.openCatalog('scratch') </pre>
<h3>Methods</h3>
<table width="969" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">createRepository(self, name)</td>
    <td>Creates a new Repository within the Catalog. <em>name</em> is a string identifying the repository. </td>
  </tr>
  <tr>
    <td valign="top">deleteRepository(self, name) </td>
    <td>Deletes the named Respository from the Catalog. </td>
  </tr>
  <tr>
    <td width="168" valign="top">getName(self)</td>
      <td width="591">Returns a string containing the name of this Catalog. </td>
  </tr>
  <tr>
    <td valign="top">getRepository(self, name, access_verb)</td>
      <td>Returns a <a href="#Repository Class">Repository</a> object.&nbsp; <em>name </em>is a repository name from listRepositories(). <em>access_verb</em> is one of the following:
              <ul>
                  <li><strong>Repository.RENEW</strong> clears the contents of an existing repository before opening. If the indicated repository does not exist, it creates one. </li>
                  <li><strong>Repository.OPEN</strong> opens an existing repository, or throws an exception if the repository is not found. </li>
                  <li><strong>Repository.ACCESS</strong> opens an existing repository, or creates a new one if the repository is not found.</li>
                  <li><strong>Repository.CREATE</strong> creates a new repository, or throws an exception if one by that name already exists.</li>
          </ul></td>
  </tr>
  <tr>
    <td valign="top">listRepositories(self)</td>
      <td>Returns a list of repository names (triple stores) managed by this Catalog.</td>
  </tr>
</table>
<h2 id="Repository Class">Repository Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A repository contains RDF data that can be queried and updated.
Access to the repository can be acquired by opening a connection to it.
This connection can then be used to query and/or update the contents of the
repository. Depending on the implementation of the repository, it may or may
not support multiple concurrent connections.</p>
<p>Please note that a repository needs to be initialized before it can be used
and that it should be shut down before it is discarded/garbage collected.
Forgetting the latter can result in loss of data (depending on the Repository
implementation)! </p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/repository/repository.py.</p>
<h3>Constructor</h3>
<p>Invoke the Repository constructor using the <a href="#AllegroGraphServer Class">AllegroGraphServer</a>.getRepository() method.</p>
<pre>    myRepository = catalog.getRepository(&quot;agraph_test&quot;, Repository.ACCESS)</pre>
<h3>Methods</h3>
<table width="969" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">getConnection(self)</td>
      <td><p>Creates a <a href="#RepositoryConnection Class">RepositoryConnection</a> object that can be used for querying and<br>
        updating the contents of the Repository.&nbsp; Returns the RepositoryConnection object. </p></td>
  </tr>
  <tr>
    <td width="168" valign="top">getDatabaseName(self)</td>
      <td width="591">Returns a string containing the name of this Repository. </td>
  </tr>


  <tr>
    <td valign="top">getSpec(self)</td>
    <td>Returns a string consisting of the catalog name concatenated with the repository name. </td>
  </tr>
  <tr>
    <td valign="top">getValueFactory(self)</td>
      <td>Return a <a href="#ValueFactory Class">ValueFactory</a> for this store.&nbsp; This is present for Aduma Sesame compatibility, but in the Python API all ValueFactory functionality has been duplicated or subsumed in the <a href="#RepositoryConnection Class">RepositoryConnection</a> class.&nbsp; It isn't necessary to manipulate the ValueFactory class at all.&nbsp; </td>
  </tr>
  <tr>
      <td valign="top">initialize(self)</td>
      <td> A Repository must be initialized before it can be used.&nbsp; Returns the initialized Repository object. </td>
  </tr>
  <tr>
    <td valign="top">isWritable(self)</td>
      <td> Checks whether this Repository is writable, i.e. if the data contained in this store can be changed. </td>
  </tr>
  <tr>
    <td valign="top"><a name="registerDatatypeMapping">registerDatatypeMapping(self, predicate=None, datatype=None, nativeType=None)</td>
      <td><p>Register an inlined datatype. <em>Predicate</em> is the URI of predicate used in the triple store. <em>Datatype</em> may be one of: XMLSchema.INT, XMLSchema.LONG, XMLSchema.FLOAT, XMLSchema.DATE, and XMLSchema.DATETIME.&nbsp; <em>NativeType</em> may be &quot;int&quot;, &quot;datetime&quot;, or &quot;float&quot;.</p>
              <p> You must supply <em>nativeType</em> and either <em>predicate</em> or <em>datatype</em>. </p>
              <p>If <em>predicate</em>, then object arguments to triples with that predicate will use an inlined encoding of type <em>nativeType</em> in their internal representation. If <em>datatype</em>, then typed literal objects with a datatype matching <em>datatype</em> will use an inlined encoding of type <em>nativeType</em>. (Duplicated in the <a href="#RepositoryConnection Class">RepositoryConnection</a> class for Python user convenience.) </p></td>
  </tr>
  <tr>
    <td valign="top">shutDown(self)</td>
      <td><p>Shuts the Repository down, releasing any resources that it keeps hold of.<br>
        Once shut down, the store can no longer be used.</p></td>
  </tr>
</table>
<h2 id="RepositoryConnection Class">RepositoryConnection Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The RepositoryConnection class is the main interface for updating data in and performing queries on a <a href="#Repository Class">Repository</a>. By default, a RespositoryConnection is in autoCommit mode, meaning  that each operation corresponds to a single transaction on the underlying triple store. autoCommit can be switched off, in which case it is up to the user to  handle transaction commit/rollback. Note that care should be taken to always  properly close a RepositoryConnection after one is finished with it, to free  up resources and avoid unnecessary locks.</p>
<p>Note that concurrent access to the same connection object is explicitly forbidden. The client must perform its own synchronization to ensure non-concurrent access.</p>
<p>Several methods take a <em>vararg</em> argument that optionally specifies a (set of)  context(s) on which the method should operate. (A context is the URI of a subgraph.) Note that a <em>vararg</em> parameter  is optional, it can be completely left out of the method call, in which case  a method either operates on a provided statement's context (if one of the  method parameters is a statement or collection of statements), or operates on  the repository as a whole, completely ignoring context. A <em>vararg</em> argument may  also be null (cast to Resource) meaning that the method operates on those  statements which have no associated context only.</p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/repository/repositoryconnection.py.</p>
<h3>Constructor</h3>
<p>RepositoryConnection(self, repository)</p>
<p>where <em>repository</em> is the <a href="#Repository Class">Repository</a> object that created this RepositoryConnection. </p>
<p>Example: The best practice is to use the <a href="#Repository Class">Repository</a>.getConnection() method, which supplies the <em>repository</em> parameter to the construction method. .</p>
<pre>&nbsp;&nbsp;&nbsp; connection = myRepository.getConnection()</pre>
<h3>General Connection Methods</h3>
<p>This table contains the repositoryConnection methods that create, maintain, search, and delete triple stores. There are following tables that list special methods for <a href="#Free Text Search Methods">Free Text Search</a>, <a href="#Prolog Rule Inference Methods">Prolog Rule Inference</a>, <a href="#Geospatial Reasoning Methods">Geospatial Reasoning</a>, <a href="#Social Network Analysis Methods">Social Network Analysis,</a> <a href="#Transactions">Transactions</a> and <a href="#SPOGI">Subject Triples Caching</a>. </p>
<table width="1057" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">add(self, arg0, arg1=None, arg2=None, contexts=None, base=None, format=None, serverSide=False)</td>
      <td><p>Calls addTriple(), addStatement(), or addFile(). Best practice is to avoid add() and use addFile(), addStatement(), and addTriple() instead.&nbsp; </p>
              <p><em>arg0</em> may be a <a href="#Statement Class">Statement</a> or a <em>filepath</em>. If so, <em>arg1</em> and <em>arg2</em> default to None. </p>
              <p><em>arg0, arg1</em>, and <em>arg2</em> may be the subject, predicate and object of a single triple. </p>
              <p><em>contexts</em> is an optional list of contexts (subgraph URIs), defaulting to None.&nbsp;A context is the URI of a subgraph. If None, the triple(s) will be added to the null context (the default or background graph).</p>
              <p><em>base</em> is the baseURI to associate with loading a file.&nbsp; Defaults to None. </p>
              <p><em>format</em> is an <a href="#RDFFormat Class">RDFFormat</a> instance. Defaults to None, which means "guess from file extension".</p>
              <p><em>serverSide</em> indicates whether the <em>filepath</em> refers to a file on the client computer or on the server.&nbsp; Defaults to False. </p></td>
  </tr>
  <tr>
    <td valign="top">addFile(self, filePath, base=None, format=None, context=None, serverSide=False)</td>
      <td><p>Loads a file into the triple store. Note that a file can be loaded into only one context. </p>
              <p><em>filepath</em> identifies the file to load. </p>
              <p><em>context</em> is an optional context URI (subgraph URI), defaulting to None.&nbsp; If None, the triple(s) will be added to the null context (the default or background graph).</p>
              <p><em>base</em> is the baseURI to associate with loading a file.&nbsp; Defaults to None. </p>
              <p><em>format</em> is an <a href="#RDFFormat Class">RDFFormat</a> instance. Defaults to None, which means "guess from file extension".</p>
              <p><em>serverSide</em> indicates whether the <em>filepath</em> refers to a file on the client computer or on the server.&nbsp; Defaults to False. </p></td>
  </tr>
  <tr>
    <td valign="top">addData(self, data, rdf_format=RDFFormat.TURTLE, base_uri=None, context=None)</td>
    <td><p>Loads data from a string into the triple store. Note that the data can be loaded into only one context. </p>
      <p><em>data</em> is the text to be loaded. </p>
      <p><em>context</em> is an optional context URI (subgraph URI), defaulting to None.&nbsp; If None, the triple(s) will be added to the null context (the default or background graph).</p>
      <p><em>base_uri</em> is used to resolve relative URIs in data.</p>
      <p><em>rdf_format</em> is the data format (an instance of <a href="#RDFFormat Class">RDFFormat</a>). Defaults to RDFFormat.TURTLE.</p>
  </tr>
  <tr>
    <td valign="top">addStatement(self, statement, contexts=None)</td>
      <td>Add the supplied <em><a href="#Statement Class">Statement</a></em> to the specified <em>contexts</em> of the repository.&nbsp; <em>contexts</em> defaults to None, which adds the statement to the null context (the default or background graph).</td>
  </tr>
  <tr>
    <td valign="top">addTriple(self, subject, predicate, object, contexts=None)</td>
      <td>Adds a single triple to the repository.&nbsp; <em>subject, predicate</em> and <em>object</em> are the three values of the triple. <em>contexts </em>is an optional list of context URIs to add the triple to, defaulting to None.&nbsp; If None, the triple will be added to the null context (the default or background graph). </td>
  </tr>
  <tr>
    <td valign="top">addTriples(self, triples_or_quads, context=ALL_CONTEXTS, ntriples=False)</td>
      <td>Add the supplied <em>triples_or_quads</em> to this repository. Each triple can be a list or a tuple of Values.<em> context</em> is the URI of a subgraph, which will be stored in the fourth field of the &quot;triple,&quot; defaulting to ALL_CONTEXTS. If <em>ntriples</em> is True, then the triples or quads are assumed to contain valid ntriples strings, and they are passed to the server with no conversion. The default value is False. </td>
  </tr>
  <tr>
    <td valign="top">clear(self, contexts=ALL_CONTEXTS)</td>
      <td>Removes all statements from the designated list of <em>contexts</em> (subgraphs) in the repository. If 
              <em>contexts</em> is ALL_CONTEXTS (the default), it clears the repository of all statements. </td>
  </tr>
  <tr>
    <td valign="top">clearNamespaces(self)</td>
      <td>Remove all namespace declarations from the current environment. </td>
  </tr>
  <tr>
    <td width="233" valign="top">close(self)</td>
      <td width="549">Closes the connection in order to free up resources. </td>
  </tr>
  <tr>
    <td valign="top">createBNode(self, nodeID=None)</td>
      <td>Creates a new blank node with the given node identifier. nodeID defaults to None. If <em>nodeID</em> is None, a new, unused node ID is generated. </td>
  </tr>
  <tr>
    <td valign="top">createLiteral(self, value, datatype=None, language=None)</td>
      <td>Create a new literal with <em>value</em>. <em>datatype</em> if supplied, should be a URI, in which case <em>value</em> should be a string. You may optionally include an RDF <em>language</em> attribute. <em>datatype </em>and <em>language</em> default to None. </td>
  </tr>
  <tr>
    <td valign="top">createRange(self, lowerBound, upperBound)</td>
      <td>Create a compound literal representing a range from <em>lowerBound</em> to <em>upperBound</em>.</td>
  </tr>
  <tr>
    <td valign="top">createStatement(self, subject, predicate, object, context=None)</td>
      <td>Create a new <a href="#Statement Class">Statement</a> object using the supplied <em>subject, predicate</em> and <em>object</em> 
    and associated <em>context</em>, which defaults to None. The context is the URI of a subgraph.</td>
  </tr>
  <tr>
    <td valign="top">createURI(self, uri=None, namespace=None, localname=None)</td>
      <td>Creates a new URI object from the supplied string-representation(s). <em>uri</em> is a string representing an entire URI.&nbsp; <em>namespace</em> and <em>localname</em> are combined to create a URI. If two non-keyword arguments are passed, it assumes they represent a<br>
    <em>namespace/localname </em>pair.</td>
  </tr>
  <tr>
    <td valign="top">deleteDuplicateStatements(mode)</td>
      <td>Deletes duplicate triples from the store. <i>mode</i> can be
      "spo" (triples are duplicates if they have the same subject,
      predicate, and object, regardless of the graph) or "spog"
      (triples are duplicates if they have the same subject,
      predicate, object, and graph). See also getDuplicateStatements
      below.</td>
  </tr>
  <tr>
    <td valign="top">export(self, handler, contexts=ALL_CONTEXTS)</td>
      <td>Exports all triples in the repository to an external file.&nbsp; <em>handler</em> is either an NTriplesWriter() object or an RDFXMLWriter() object.&nbsp; The export may be optionally confined to a list of <em>contexts</em> (default is ALL_CONTEXTS). Each context is the URI of a subgraph. </td>
  </tr>
  <tr>
    <td valign="top">exportStatements(self, subj, pred, obj, includeInferred, handler, contexts=ALL_CONTEXTS)</td>
      <td>Exports all triples that match <em>subj</em>, <em>pred</em> and/or <em>obj</em>. &nbsp; May optionally <em>includeInferred</em> statements provided by RDFS++ inference (default is False). <em>handler</em> is either an NTriplesWriter() object or an RDFXMLWriter() object.&nbsp; The export may be optionally confined to a list of <em>contexts</em> (default is ALL_CONTEXTS). Each context is the URI of a subgraph. </td>
  </tr>
  <tr>
    <td valign="top">getAddCommitSize(self)</td>
    <td>Returns the current setting of the add_commit_size property. See setAddCommitSize(). </td>
  </tr>
  <tr>
    <td valign="top">getContextIDs(self)</td>
      <td>Return a list of context URIs, one for each subgraph referenced by a quad in 
    the triple store. Omits the default context because its ID would be null.</td>
  </tr>
  <tr>
    <td valign="top">getDuplicateStatements(mode)</td>
      <td>Gets duplicate triples in the store. <i>mode</i> can be
      "spo" (triples are duplicates if they have the same subject,
      predicate, and object, regardless of the graph) or "spog"
      (triples are duplicates if they have the same subject,
      predicate, object, and graph). See also deleteDuplicateStatements
      above.</td>
  </tr>
  <tr>
    <td valign="top">getNamespace(self, prefix)</td>
      <td>Returns the namespace that is associated with <em>prefix</em>, if any. </td>
  </tr>
  <tr>
    <td valign="top">getNamespaces(self)</td>
      <td>Returns a Python dictionary of prefix/namespace pairings. The default namespaces are: rdf, rdfs, xsd, owl, fti, dc, and dcterms. </td>
  </tr>
  <tr>
    <td valign="top">getSpec(self)</td>
    <td>Returns a string composed of the catalog name concatenated with the repository name. </td>
  </tr>
  <tr>
    <td valign="top">getStatements(self, subject, predicate,  object, contexts=ALL_CONTEXTS, includeInferred=False,<br>
limit=None, tripleIDs=False, output=None, output_format=RDFFormat.NQX)</td>
      <td>Gets all statements with a specific <em>subject</em>, <em>predicate</em> and/or <em>object</em> from the repository. The result is optionally restricted to the specified set of named <em>contexts</em> (default is ALL_CONTEXTS). A context is the URI of a subgraph. Returns a <a href="#RepositoryResult Class">RepositoryResult</a> iterator that produces a '<a href="#Statement Class">Statement</a>' each time that 'next' is called. May optionally <em>includeInferred</em> statements provided by RDFS++ inference (default is False). Takes an optional <em>limit</em> on the number of statements to return.&nbsp; If <em>tripleIDs</em> is True, the output includes the triple ID field (the fifth field of the quad).
        To serialize the statements to a file or stream, pass a file path or a file-like object as the <em>output</em> parameter.
        Set <em>output_format</em> to an instance of RDFFormat to control the serialization format.
        Note that if the <em>output</em> parameter is used the function returns None instead of a RepositoryResult.
      </td>
  </tr>
  <tr>
    <td valign="top">getStatementsById(self, ids, output=None, output_format=RDFFormat.NQX) </td>
    <td>Return all statements whose triple ID matches an ID in the list of <em>ids.</em>
      To serialize the statements to a file or stream, pass a file path or a file-like object as the <em>output</em> parameter.
      Set <em>output_format</em> to an instance of RDFFormat to control the serialization format.
      Note that if the <em>output</em> parameter is used the function returns None instead of a RepositoryResult.   </td>
  </tr>
  <tr>
    <td valign="top">getValueFactory(self)</td>
    <td>Returns the <a href="#ValueFactory Class">ValueFactory</a> object associated with this RepositoryConnection. </td>
  </tr>
  <tr>
    <td valign="top">isEmpty(self)</td>
      <td>Returns True if size() is zero.&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">prepareBooleanQuery(self, queryLanguage, queryString, baseURI=None)</td>
      <td>Parse <em>queryString</em> into a <a href="#Query Class">Query</a> object which can be executed against the RDF storage. <em>queryString</em> must be an ASK query. The result is true or false. <em>queryLanguage</em> is one of SPARQL, PROLOG, or COMMON_LOGIC.&nbsp; <em>baseURI</em> optionally provides a URI prefix (defaults to None). Returns a <a href="#Query Class">Query</a> object.&nbsp; The result of query execution will be True of False. </td>
  </tr>
  <tr>
    <td valign="top">prepareGraphQuery(self, queryLanguage, queryString, baseURI=None)</td>
      <td>Parse <em>queryString</em> into a <a href="#Query Class">Query</a> object which can be executed against the RDF storage. <em>queryString</em> must be a CONSTRUCT or DESCRIBE query. <em>queryLanguage</em> is one of SPARQL, PROLOG, or COMMON_LOGIC.&nbsp; <em>baseURI</em> optionally provides a URI prefix (defaults to None). Returns a <a href="#Query Class">Query</a> object. The result of query execution is an iterator of <a href="#Statement Class">Statement</a>s/quads.</td>
  </tr>
  <tr>
    <td valign="top">prepareTupleQuery(self, queryLanguage, queryString, baseURI=None)</td>
      <td>Embed <em>queryString</em> into a <a href="#Query Class">Query</a> object which can be executed against the RDF storage. <em>queryString</em> must be a SELECT query. <em>queryLanguage</em> is one of SPARQL, PROLOG, or COMMON_LOGIC.&nbsp; <em>baseURI</em> optionally provides a URI prefix (defaults to None). Returns a <a href="#Query Class">Query</a> object. The result of query execution is an iterator of tuples.</td>
  </tr>
  <tr>
    <td valign="top">registerDatatypeMapping(self, predicate=None, datatype=None, nativeType=None)</td>
      <td><p>Register an inlined datatype. <em>Predicate</em> is the URI of predicate used in the triple store. <em>Datatype</em> may be one of: XMLSchema.INT, XMLSchema.LONG, XMLSchema.FLOAT, XMLSchema.DATE, and XMLSchema.DATETIME.&nbsp; <em>NativeType</em> may be &quot;int&quot;, &quot;datetime&quot;, or &quot;float&quot;.</p>
              <p> You must supply <em>nativeType</em> and either <em>predicate</em> or <em>datatype</em>. </p>
              <p>If <em>predicate</em>, then object arguments to triples with that predicate will use an inlined encoding of type <em>nativeType</em> in their internal representation. If <em>datatype</em>, then typed literal objects with a datatype matching <em>datatype</em> will use an inlined encoding of type <em>nativeType</em>.</p></td>
  </tr>
  <tr>
    <td valign="top">remove(self, arg0, arg1=None, arg2=None, contexts=None)</td>
      <td><p>Calls removeTriples() or removeStatement().&nbsp; Best practice would be to avoid remove() and use removeTriples() or removeStatement() directly. </p>
              <p><em>arg0</em> may be a <a href="#Statement Class">Statement</a>.&nbsp; If so, then <em>arg1</em> and <em>arg2</em> default to None. </p>
              <p><em>arg0, arg1</em>, and <em>arg2</em> may be the subject, predicate and object of a triple.</p>
              <p><em>contexts</em> is an optional list of contexts, defaulting to None. </p></td>
  </tr>
  <tr>
    <td valign="top">removeNamespace(self, prefix)</td>
      <td>Remove the namespace associate with <em>prefix</em>. </td>
  </tr>
  <tr>
    <td valign="top">removeQuads(self, quads, ntriples=False)</td>
      <td>Remove enumerated quads from this repository. Each <em>quad</em> can be a list or a tuple of Values. If <em>ntriples</em> is True (default is False), then the quads are assumed to contain valid ntriples strings, and they are passed to the server with no conversion. </td>
  </tr>
  <tr>
    <td valign="top">removeQuadsByID(self, tids)</td>
    <td><em>tids</em> contains a list of triple IDs (integers). Remove all quads with IDs that match. </td>
  </tr>
  <tr>
    <td valign="top">removeStatement(self, statement, contexts=None)</td>
      <td>Removes the supplied <em><a href="#Statement Class">Statement</a></em>(s) from the specified <em>contexts</em> (default is None). </td>
  </tr>
  <tr>
    <td valign="top">removeTriples(self, subject, predicate, object, contexts=None)</td>
      <td>Removes the triples with the specified <em>subject</em>, <em>predicate</em> and <em>object</em><br>
    from the repository, optionally restricted to the specified <em>contexts</em> (defaults to None)..</td>
  </tr>
  <tr>
    <td valign="top">setAddCommitSize(self, triple_count) </td>
    <td>The threshold for commit size during triple add operations. &quot;Set to 0 (zero) or None to clear size-based autocommit behavior. When set to an integer triple_count &gt; 0, loads and adds commit each triple_count triples added and at the end of the triples being added.</td>
  </tr>
  <tr>
    <td valign="top">setNamespace(self, prefix, namespace)</td>
      <td>Define (or redefine) a <em>namespace</em> associated with <em>prefix</em>. </td>
  </tr>
  <tr>
    <td valign="top">size(self, contexts=ALL_CONTEXTS)</td>
      <td>Returns the number of (explicit) statements that are in the specified <em>contexts</em> in this repository. contexts defaults to ALL_CONTEXTS, but can be a context URI or a tuple of context URIs from getContextIDs(). Use 'null' to get the size of the default graph (the unnamed context). </td>
  </tr>
</table>
<h3 id="Triple Index Methods">Triple Index Methods</h3>
<p>These repositoryConnection methods support user-defined triple indices.&nbsp; See <a href="../triple-index.html">AllegroGraph Triple Indices</a> for more information on this topic. </p>
<table width="792" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td valign="top">listIndices(self)</td>
        <td><p>Returns a tuple containing a list of the current set of triple indices.</p></td>
    </tr>
    <tr>
        <td valign="top">listValidIndices(self)</td>
        <td>Returns a tuple containing the list of all possible triple indices. </td>
    </tr>
    <tr>
        <td valign="top">addIndex(self, type)</td>
        <td>Adds a specific type of index to the current set of triple indices.&nbsp;<em> type </em>is a string containing one of the following index names: spogi, spgoi, sopgi, sogpi, sgpoi, sgopi, psogi, psgoi, posgi, pogsi, pgsoi, pgosi, ospgi, osgpi, opsgi, opgsi, ogspi, ogpsi, gspoi, gsopi, gpsoi, gposi, gospi, gopsi, or i. </td>
    </tr>
    <tr>
        <td valign="top">dropIndex(self, type)</td>
        <td>Removes a specific type of index to the current set of triple indices.&nbsp;<em> type </em>is a string containing one of the following index names: spogi, spgoi, sopgi, sogpi, sgpoi, sgopi, psogi, psgoi, posgi, pogsi, pgsoi, pgosi, ospgi, osgpi, opsgi, opgsi, ogspi, ogpsi, gspoi, gsopi, gpsoi, gposi, gospi, gopsi, or i. </td>
    </tr>
</table>
<h3 id="Geospatial Reasoning Methods"></h3>
<h3 id="Free Text Search Methods">Free Text Search Methods</h3>
<p>The following repositoryConnection method supports free-text indexing in AllegroGraph. </p>
<table width="792" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">createFreeTextIndex(self, name, predicates=None, indexLiterals=None, indexResources=None,<br>
indexFields=None, minimumWordSize=None, stopWords=None, wordFilters=None)</td>
    <td> Create a free-text index with the given parameters. <em>name</em> is a string identifying the new index. 
If no <em>predicates</em> are given, triples are indexed regardless of 
predicate. 
<em>indexLiterals</em> determines which literals to index. It can be 
True (the default), False, or a list of resources, indicating 
the literal types that should be indexed. 
<em>indexResources</em> determines which resources are indexed. It can 
be True, False (the default), or &quot;short&quot;, to index only the 
part of resources after the last slash or hash character. 
<em>indexFields</em> can be a list containing any combination of the<br>
elements &quot;subject&quot;, &quot;predicate&quot;, &quot;object&quot;, and<br>
&quot;graph&quot;. The default is [&quot;object&quot;]. 
<em>minimumWordSize</em>, an integer, and determines the minimum size a 
word must have to be indexed. The default is 3. 
<em>stopWords</em> should hold a list of words that should not be 
indexed. When not given, a list of common English words is 
used. 
<em>wordFilters</em> can be used to apply some normalizing filters to 
words as they are indexed or queried. Can be a list of filter 
names. Currently, only &quot;drop-accents&quot; and &quot;stem.english&quot; 
are supported. </td>
  </tr>
  <tr>
    <td valign="top">deleteFreeTextIndex(self, name)</td>
    <td>Deletes the named index. </td>
  </tr>
  <tr>
    <td valign="top">evalFreeTextSearch(self, pattern, infer=False,  limit=None, index=None)</td>
    <td>Return an array of statements for the given free-text pattern search. If no index is provided, all indices will be used. </td>
  </tr>
  <tr>
    <td valign="top">getFreeTextIndexConfiguration(self, name)</td>
    <td>Returns a Python dictionary containing all of the configuration settings of the named index. </td>
  </tr>
  <tr>
    <td valign="top">listFreeTextIndices(self)</td>
    <td>List the free-text indices. </td>
  </tr>
  <tr>
    <td valign="top">modifyFreeTextIndex(self, name, predicates=None, indexLiterals=None, indexResources=None,<br>
indexFields=None, minimumWordSize=None, stopWords=None, wordFilters=None,<br>
reIndex=None)</td>
    <td><em>name</em> is a string identifying the index to be modified. If no <em>predicates</em> are given, triples are indexed regardless of predicate. <em>indexLiterals</em> determines which literals to index. It can be True (the default), False, or a list of resources, indicating the literal types that should be indexed. <em>indexResources</em> determines which resources are indexed. It can be True, False (the default), or &quot;short&quot;, to index only the part of resources after the last slash or hash character. <em>indexFields</em> can be a list containing any combination of the<br>
elements &quot;subject&quot;, &quot;predicate&quot;, &quot;object&quot;, and<br>
&quot;graph&quot;. The default is [&quot;object&quot;]. <em>minimumWordSize</em>, an integer, and determines the minimum size a word must have to be indexed. The default is 3. <em>stopWords</em> should hold a list of words that should not be indexed. When not given, a list of common English words is used. <em>wordFilters</em> can be used to apply some normalizing filters to words as they are indexed or queried. Can be a list of filter names. Currently, only &quot;drop-accents&quot; and &quot;stem.english&quot; are supported. <em>reIndex</em> if True (the default) will rebuild the index. If False, it will apply the new settings to new triples only, while maintaining the index data for existing triples. </td>
  </tr>
</table>
<p>Note that text search is implemented through a SPARQL query using a &quot;magic&quot; predicate called <strong>fti:search</strong>. See the AllegroGraph Python API Tutorial for an example of how to set up this search. </p>
<h3 id="Prolog Rule Inference Methods">Prolog Rule Inference Methods</h3>
<p>These repositoryConnection methods support the use of Prolog rules in AllegroGraph. Any use of Prolog rules requires that you create a <a href="#Transactions">dedicated session</a> to run them in. </p>
<table width="792" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">addRules(self, rules, language=None)</td>
    <td><p>Add a sequence of one or more rules (in ASCII format).<br>
      If the <em>language</em> is QueryLanguage.PROLOG, rule declarations start with '&lt;-' or '&lt;--'. The former appends a new rule; the latter overwrites any rule with the same predicate. <em>language</em> defaults to QueryLanguage.PROLOG. <br>
      For use with a <a href="#Transactions">dedicated session</a>. </p>      </td>
  </tr>
  <tr>
    <td valign="top">loadRules(self, file ,language=None)</td>
    <td>Load a file of rules. <em>file</em> is assumed to reside on the client machine. <em>language</em> defaults to QueryLanguage.PROLOG. 
For use with a <a href="#Transactions">dedicated session</a>. </td>
  </tr>
</table>
<h3 id="Geospatial Reasoning Methods">Geospatial Reasoning Methods</h3>
<p>These repositoryConnection methods support geospatial reasoning. </p>
<table width="792" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">createBox(self, xMin=None, xMax=None, yMin=None, yMax=None)</td>
    <td>Create a rectangular search region (a box) for geospatial search. This method works for both Cartesian and spherical coordinate systems. xMin, xMax may be used to input latitude. yMin, yMax may be used to input longitude.</td>
  </tr>
  <tr>
    <td valign="top">createCircle(self, x, y, radius, unit=None)</td>
    <td>Create a circular search region for geospatial search. This method works for both Cartesian and spherical coordinate systems.<em> radius</em> is the radius of the circle expressed in the designated <em>unit</em>, which defaults to the unit assigned to the coordinate system. <em>x</em> and <em>y</em> locate the center of the circle and may be used for latitude and longitude. </td>
  </tr>
  <tr>
    <td valign="top">createCoordinate(self, x=None, y=None, lat=None, long=None)</td>
    <td>Create a coordinate point in a geospatial coordinate system. Must include <em>x</em> and <em>y</em>, or <em>lat</em> and <em>long.</em> Use this method to create the object value for a location triple. </td>
  </tr>
  <tr>
    <td valign="top">createLatLongSystem(self, unit='degree', scale=None, latMin=None, latMax=None, longMin=None, longMax=None)</td>
    <td>Create a spherical coordinate system for geospatial location matching. <em>unit</em> can be 'degree', 'mile', 'radian', or 'km'. <em>scale</em> should be your estimate of the size of a typical search region in the latitudinal direction. <em>latMin</em> and <em>latMax</em> are the bottom and top borders of the coordinate system. <em>longMin</em> and <em>longMax</em> are the left and right sides of the coordinate system. </td>
  </tr>
  <tr>
    <td valign="top">createPolygon(self, vertices, uri=None, geoType=None)</td>
    <td>Create a polygonal search region for geospatial search. The vertices are saved as triples in AllegroGraph. <em>vertices</em> is a list of (x, y) pairs such as [(51.0, 2.00),(60.0, -5.0),(48.0,-12.5)]. <em>uri</em> is an optional subject value for the vertex triples, in case you want to manipulate them. <em>geoType</em> is 'CARTESIAN' or 'SPHERICAL', but defaults to None. </td>
  </tr>
  <tr>
    <td valign="top">createRectangularSystem(self, scale=1, unit=None, xMin=0, xMax=None, yMin=0, yMax=None)</td>
    <td>Create a Cartesian coordinate system for geospatial location matching. <em>scale</em> should be your estimate of the Y size of a typical search region. <em>unit </em>must be None. <em>xMin</em> and <em>xMax</em> are the left and right edges of the rectangle. <em>yMin</em> and <em>yMax</em> are the bottom and top edges of the rectangle. </td>
  </tr>
  <tr>
    <td valign="top">getGeoType(self)</td>
    <td>Returns what type of geospatial object it is. </td>
  </tr>
  <tr>
    <td valign="top">setGeoType(self)</td>
    <td>Sets the geoType of a geospatial object. </td>
  </tr>
</table>
<h3 id="Social Network Analysis Methods">Social Network Analysis Methods</h3>
<p>The following repositoryConnection methods support Social Network Analysis in AllegroGraph. The Python API to the Social Network Analysis methods of AllegroGraph requires Prolog queries, and therefore must be run in a <a href="#Transactions">dedicated session</a>. </p>
<table width="792" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">registerNeighborMatrix(self, name, generator, group_uris, max_depth=2)</td>
    <td>Construct a neighbor matrix named 'name'. The generator named 'generator' is applied 
to each URI in 'group_uris' (a collection of fullURIs or qnames (strings)),<br>
computing edges to max depth 'max_depth'.<br>
For use in a <a href="#Transactions">dedicated session</a>. </td>
  </tr>
  <tr>
    <td valign="top">registerSNAGenerator(self, name, subjectOf=None, objectOf=None, undirected=None, generator_query=None)</td>
    <td>Create (and remember) a generator named 'name'. 
If one already exists with the same name; redefine it. 
'subjectOf', 'objectOf' and 'undirected' expect a list of predicate URIs, expressed as 
fullURIs or qnames, that define the edges traversed by the generator. 
Alternatively, instead of an adjacency map, one may provide a 'generator_query', 
that defines the edges.<br>
For use in a <a href="#Transactions">dedicated session</a>. </td>
  </tr>
</table>


<h3 id="Transactions">Transactions</h3>
<p>AllegroGraph lets you set up a special RepositoryConnection (a &quot;session&quot;) that supports transaction semantics. You can add statements to this session until you accumulate all the triples you need for a specific transaction. Then you can commit the triples in a single act. Up to that moment the triples will not be visible to other users of the repository.</p>
<p>If anything interrupts the accumulation of triples building to the transaction, you can roll back the session. This discards all of the uncommitted triples and resynchronizes the session with the repository as a whole. </p>
<p>Closing the session deletes all uncommitted triples, all rules, generators and matrices that were created in the session. Rules, generators and matrices cannot be committed. They persist as long as the session persists. </p>
<table width="792" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">openSession(self)</td>
    <td>Open a dedicated session. </td>
  </tr>
  <tr>
    <td valign="top">closeSession(self)</td>
    <td>Close a dedicated session connection. </td>
  </tr>
  <tr>
    <td valign="top">session(self,  autocommit=False, lifetime=None, loadinitfile=False)</td>
    <td><p>A dedicated connection context manager for use with the 'with' statement. Automatically calls openSession() at block start and closeSession() at block end. </p>
    <p> If autocommit is True, commits are done on each request, otherwise 
you will need to call commit() or rollback() as appropriate for your 
application.</p>
    <p> lifetime is an integer specifying the idle timeout of 
        the session, in seconds. If lifetime is not specified, it defaults to the
        value of the <a href="../daemon-config.html#DefaultSessionTimeout">DefaultSessionTimeout</a> configuration directive. If specified, its value can be
        no larger than the value of the <a href="../daemon-config.html#MaximumSessionTimeout">MaximumSessionTimeout</a> configuration directive. See the
        <a href="../daemon-config.html#session-values">Session directives</a> 
        section in
        <a href="../daemon-config.html">Server Configuration and Control</a> for
        more information.
    </p>
    <p> If loadinitfile is True, then the current initfile will be loaded<br>
  for you when the session starts.</p></td>
  </tr>
  <tr>
    <td valign="top">commit(self)</td>
    <td>Commits changes on a dedicated connection. </td>
  </tr>
  <tr>
    <td valign="top">rollback(self)</td>
    <td>Rolls back changes on a dedicated connection. </td>
  </tr>
</table>
<h3 id="SPOGI">Subject Triples Caching </h3>
<p>You can enable subject triple caching to speed up queries where the same subject URI appears in multiple patterns. The first time AllegroGraph retrieves triples for a specific resource, it caches the triples in memory. Subsequent query patterns that ask for the same subject URI can retrieve the matching triples very quickly from the cache. The cache has a size limit and automatically rolls over as that limit is exceeded.</p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
      <td valign="top">enableSubjectTriplesCache(self, size=None)</td>
      <td>Maintain a cache of size 'size' that caches, for each accessed 
resource, quads where the resource appears in subject position. 
This can accelerate the performance of certain types of queries. 
The size is the maximum number of subjects whose triples will be cached. 
Default is 100,000.</td>
    </tr>
    <tr>
      <td valign="top">disableSubjectTriplesCache(self)</td>
      <td>Turn of caching. </td>
    </tr>
    <tr>
      <td valign="top">getSubjectTriplesCacheSize(self)</td>
      <td>Return the current size of the subject triples cache.</td>
    </tr>
</table>

<h2 id="RDFFormat Class">RDFFormat Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The RDFFormat class is an enumeration describing the data formats supported by AllegroGraph when importing RDF data.&nbsp; </p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/rio/rdfformat.py.</p>
<h3>Static members</h3>
<table width="969" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td valign="top">RDFFormat.RDFXML</td>
    <td>The <a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> file format.</td>
  </tr>
  <tr>
    <td valign="top">RDFFormat.NTRIPLES</td>
    <td>The <a href="http://www.w3.org/TR/n-triples/">N-Triples</a> file format.</td>
  </tr>
  <tr>
    <td valign="top">RDFFormat.NQUADS</td>
    <td>The <a href="http://www.w3.org/TR/n-quads/">N-Quads</a> file format.</td>
  </tr>
  <tr>
    <td valign="top">RDFFormat.NQX</td>
    <td>The <a href="http://franz.com/agraph/support/documentation/current/triple-attributes.html#nqx-file">NQX</a> file format - an extension to N-Quads that can encode triple attributes.</td>
  </tr>
  <tr>
    <td valign="top">RDFFormat.TURTLE</td>
    <td>The <a href="http://www.w3.org/TR/turtle/">Turtle</a> file format.</td>
  </tr>
  <tr>
    <td valign="top">RDFFormat.TRIX</td>
    <td>The <a href="http://swdev.nokia.com/trix/">TriX</a> file format.</td>
  </tr>
  <tr>
    <td valign="top">RDFFormat.TRIG</td>
    <td>The <a href="http://www.w3.org/TR/trig/">TriG</a> file format.</td>
  </tr>
</table>

<h2 id="Query Class">Query Class&nbsp;(and Subclasses) &nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The Query class is 


non-instantiable. It is an abstract class from which the three query subclasses are derived.&nbsp; It is included here because of its methods, which are inherited by the subclasses.&nbsp; </p>
<p>A query on a <a href="#Repository Class">Repository</a> that can be formulated in one of the 
    supported query languages (for example SPARQL). It allows one to 
    predefine bindings in the query to be able to reuse the same query with 
    different bindings. &nbsp; </p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/query/query.py.</p>
<h3>Constructor</h3>
<p>The best practice is to allow the <a href="#RepositoryConnection Class">RepositoryConnection</a> object to create an instance of one of the Query subclasses (<a href="#Subclass TupleQuery">TupleQuery</a>, <a href="#Subclass GraphQuery">GraphQuery</a>, <a href="#Subclass BooleanQuery">BooleanQuery</a>). There is no reason for the Python application programmer to create a Query object directly.&nbsp; </p>
<pre>   tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
   result = tupleQuery.evaluate()</pre>
<h3>Methods</h3>
<table width="969" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
      <td valign="top">evaluate_generic_query(self, count=False, accept=None)</td>
      <td>Evaluate a SPARQL or PROLOG query. If SPARQL, it may be a 'select', 'construct', 'describe' or 'ask' query. Return a <a href="#QueryResult Class">QueryResult</a> object, unless the <em>accept</em> parameter is set to


 'application/sparql-results+xml'

or 


 'application/sparql-results+json'

to return the results as a string in xml or json format. (Best practice is to use (and evaluate) one of the more specific query subclasses instead of using the Query class directly.)&nbsp; </td>
  </tr>
    <tr>
      <td valign="top">getBindings(self)</td>
      <td>Retrieves the bindings that have been set on this query in the form of a dictionary. </td>
  </tr>
    <tr>
      <td valign="top">getDataset(self)</td>
      <td>Returns the current dataset setting for this query. </td>
  </tr>
    <tr>
      <td valign="top">getIncludeInferred(self)</td>
      <td>Returns whether or not this query will return inferred statements (if any<br>
  are present in the repository).</td>
  </tr>
    <tr>
      <td valign="top">removeBinding(self, name)</td>
      <td><p>Removes the named binding so that it has no value.</p></td>
  </tr>
    <tr>
      <td width="168" valign="top">setBinding(self, name, value)</td>
      <td width="591">Binds the named attribute to the supplied value. Any value that was previously bound to the specified attribute will be overwritten. </td>
  </tr>
    <tr>
      <td valign="top">setBindings(self, dict)</td>
      <td>Sets multiple bindings using a dictionary of attribute names and values. </td>
  </tr>
    <tr>
      <td valign="top">setCheckVariables(self, setting)</td>
      <td> If true, the presence of variables in the SELECT clause not referenced in a triple pattern <br>
  are flagged.</td>
  </tr>
    <tr>
      <td valign="top">setContexts(self, contexts)</td>
      <td>Assert a set of contexts (a list of subgraph URIs) that filter all triples.</td>
  </tr>
    <tr>
      <td valign="top">setDataset(self, dataset)</td>
      <td>Specifies the dataset against which to evaluate a query, overriding any dataset that is specified in the query itself.</td>
  </tr>
    <tr>
      <td valign="top">setIncludeInferred(self, includeInferred)</td>
      <td>Determines whether results of this query should include inferred statements (if any inferred statements are present in the repository). Inference is turned off by default (which is the opposite of standard Sesame behavior). The default value of setIncludeInferred() is True. </td>
  </tr>
</table>
<h3 id="Subclass TupleQuery">Subclass TupleQuery&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a> </h3>
<p>This subclass is used with SELECT queries.&nbsp; Use the <a href="#RepositoryConnection Class">RepositoryConnection</a> object's <strong>prepareTupleQuery()</strong> method to create a TupleQuery object. The results of the query are returned in a <a href="#RepositoryResult Class">QueryResult</a> iterator that yields a sequence of bindingSets.</p>
<p><strong>Methods</strong></p>
<p>TupleQuery uses all the methods of the <a href="#Query Class">Query</a> class, plus one more: </p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td valign="top">evaluate(self,  count=False)</td>
        <td>Execute the embedded query against the RDF store. Return 
an iterator that produces for each step a tuple of values 
(resources and literals) corresponding to the variables 
or expressions in a 'select' clause (or its equivalent).

To serialize the returned tuples to a file or stream, pass a file path or a file-like object as the <em>output</em> parameter.
Set <em>output_format</em> to an instance of TupleFormat to control the serialization format.
Note that if the <em>output</em> parameter is used the function returns None.
        </td>
    </tr>
</table>
<h3 id="Subclass GraphQuery">Subclass GraphQuery&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a> </h3>
<p>This subclass is used with CONSTRUCT and DESCRIBE queries.&nbsp; Use the <a href="#RepositoryConnection Class">RepositoryConnection</a> object's <strong>prepareGraphQuery()</strong> method to create a GraphQuery object. The results of the query are returned in a <a href="#RepositoryResult Class">RepositoryResult</a> iterator that yields a sequence of bindingSets.</p>
<p><strong>Methods</strong></p>
<p>GraphQuery uses all the methods of the <a href="#Query Class">Query</a> class, plus one more:</p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td valign="top">evaluate(self)</td>
        <td>Execute the embedded query against the RDF store.

          Returns a RepositoryResult object.

          To serialize the statements to a file or stream, pass a file path or a file-like object as the <em>output</em> parameter.
          Set <em>output_format</em> to an instance of RDFFormat to control the serialization format.
          Note that if the <em>output</em> parameter is used the function returns None instead of a RepositoryResult.
        </td>
    </tr>
</table>
<h3 id="Subclass BooleanQuery">Subclass BooleanQuery &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h3>
<p>This subclass is used with ASK queries.&nbsp; Use the <a href="#RepositoryConnection Class">RepositoryConnection</a> object's <strong>prepareBooleanQuery()</strong> method to create a BooleanQuery object. The results of the query are True or False.</p>
<p><strong>Methods</strong></p>
<p>BooleanQuery uses all the methods of the <a href="#Query Class">Query</a> class, plus one more:</p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td valign="top">evaluate(self)</td>
        <td>Execute the embedded query against the RDF store.</td>
    </tr>
</table>

<h2 id="QueryResult Class">QueryResult Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/query/queryresult.py.</p>
<p>A QueryResult object is simply an iterator that also has a close() method that must be called to free resources.
Such objects are returned as a result of SPARQL and PROLOG query evaluation and should not be constructed directly. The recommended usage looks like this:</p>
<pre>        tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
        with contextlib.closing(tupleQuery.evaluate()) as results:
		    for result in results:
		        print result
</pre>

<h3>Methods</h3>
<table width="969" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td width="168" valign="top">close(self)</td>
    <td width="591">Shut down the iterator to be sure the resources are freed up. It is safe to call this method multiple times.</td>
  </tr>
  <tr>
    <td valign="top">next(self)</td>
    <td>Return the next <a href="#Statement Class">Statement</a> in the answer, if there is one. Otherwise raise a StopIteration exception.</td>
  </tr>
</table>

<h3 id="Subclass TupleQueryResult">Subclass TupleQueryResult &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h3>
<p>A QueryResult subclass used for queries that return tuples.</p>

<h4>Methods</h4>
<table width="969" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td width="168" valign="top">getBindingNames(self)</td>
    <td width="591">Get the names of the bindings (a list of strings), in order of projection.</td>
  </tr>
</table>

<h3 id="Subclass GraphQueryResult">Subclass GraphQueryResult &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h3>
<p>A QueryResult subclass used for queries that return statements. Objects of this class are also <a href="#RepositoryResult Class">RepositoryResult</a> instances.</p>

<h2 id="RepositoryResult Class">RepositoryResult Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A RepositoryResult object is a result collection of <a href="#Statement Class">Statement</a> that can be iterated over. It  keeps an open connection to the backend for lazy retrieval of individual  results. Additionally it has some utility methods to fetch all results and  add them to a collection.<br>
  <br>
  By default, a RepositoryResult is not necessarily a (mathematical) set: it  may contain duplicate objects. Duplicate filtering can be  switched on,  but this should not be used lightly as the filtering mechanism is potentially  memory-intensive.<br>
  <br>
  A RepositoryResult must be closed after use to free up  any resources (open connections, read locks, etc.) it has on the underlying  repository.</p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/repository/repositoryresult.py.</p>
<h3>Constructor</h3>
<p>Best practice is to allow a querySubclass.evaluate() method to create and return the RepositoryResult object. There is no reason for the Python application programmer to create a RepositoryResult object directly.&nbsp; </p>
<pre>        graphQuery = conn.prepareGraphQuery(QueryLanguage.SPARQL, queryString)
        with contextlib.closing(graphQuery.evaluate()) as results:
		    for result in results:
		        print result
</pre>
<h3>Methods</h3>
<table width="969" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
      <td width="168" valign="top">close(self)</td>
        <td width="591">Shut down the iterator to be sure the resources are freed up. It is safe to call this method multiple times.</td>
    </tr>
    <tr>
      <td valign="top">next(self)</td>
        <td>Return the next <a href="#Statement Class">Statement</a> in the answer, if there is one. Otherwise raise a StopIteration exception.</td>
    </tr>
    <tr>
      <td valign="top">enableDuplicateFilter(self)</td>
        <td> Switches on duplicate filtering while iterating over objects. The  RepositoryResult will keep track of the previously returned objects in a set and on calling next() will ignore any  objects that already occur in this set.<br>            <br>
         Caution: use of this filtering mechanism is potentially memory-intensive.</td>
    </tr>
    <tr>
      <td valign="top">asList(self)</td>
        <td>Returns a list containing all objects of this RepositoryResult in 
order of iteration. The RepositoryResult is fully consumed and 
automatically closed by this operation.</td>
    </tr>
    <tr>
      <td valign="top">addTo(self, collection)</td>
        <td>Adds all objects of this RepositoryResult to the supplied collection. The 
RepositoryResult is fully consumed and automatically closed by this 
operation.</td>
    </tr>
    <tr>
      <td valign="top">rowCount(self)</td>
        <td>Returns the number of result items stored in this object. </td>
    </tr>
</table>
<p>&nbsp;</p>
<h2 id="Statement Class">Statement Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>


<p>A Statement is a client-side triple.&nbsp; It encapsulates the subject, predicate, object and context (subgraph) values of a single triple and makes them available. </p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/model/statement.py.</p>
<h3>Constructor</h3>
<p>Statement(self, subject, predicate, object, context=None)</p>
<ul>
  <li><em>subject, predicate, object </em>are the values of a typical triple.</li>
  <li><em>context </em> is the optional URI of the subgraph of the repository.</li>
</ul>
<p>Example:&nbsp; Best practice is to allow the <a href="#RepositoryConnection Class">RepositoryConnection</a>.createStatement() method to create and return the Statement object. There is no reason for the Python application programmer to create a Statement object directly.&nbsp; </p>
<pre>    stmt1 = conn.createStatement(alice, age, fortyTwo)</pre>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
      <td valign="top">getContext(self)</td>
      <td>Returns the value in the fourth position of the stored tuple (the subgraph URI).</td>
  </tr>
  <tr>
      <td valign="top">getObject(self)</td>
      <td>Returns the value in the third position of the stored tuple. </td>
  </tr>
  <tr>
      <td valign="top">getPredicate(self)</td>
      <td>Returns the value in the second position of the stored tuple. </td>
  </tr>
  <tr>
      <td valign="top">getSubject(self)</td>
      <td>Returns the value in the first position of the stored tuple. </td>
  </tr>
  <tr>
      <td width="168" valign="top">setQuad(self, string_tuple)</td>
      <td width="591"><p>Stores a string_tuple of a triple or quad.&nbsp; This method is called only by an internal method of the <a href="#RepositoryResult Class">RepositoryResult</a> class.&nbsp; There is no need for a Python application programmer to use it. </p></td>
  </tr>
</table>
<p>&nbsp;</p>
<h2 id="ValueFactory Class">ValueFactory Class&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>A ValueFactory is a factory for creating URIs, blank nodes, literals and <a href="#Statement Class">Statement</a>s.&nbsp; In the AllegroGraph Python interface, the ValueFactory class would be regarded as obsolete.&nbsp; Its functions have been subsumed by the expanded capability of the RepositoryConnection class. It is documented here for the convenience of the person who is porting an application from Aduma Sesame. &nbsp; </p>
<p>Source: /AllegroGraphDirectory/src/franz/openrdf/model/valuefactory.py.</p>
<h3>Constructor</h3>
<p>ValueFactory(self, store)</p>
<ul>
    <li><em>store </em>is the <a href="#Repository Class">Repository</a> object that generated this ValueFactory.</li>
</ul>
<p>Example:&nbsp; Best practice is to allow the <a href="#Repository Class">Repository</a> constructor to generate the ValueFactory automatically at the same time that the Repository object is created.&nbsp; There is no reason for a Python application programmer to attempt this step manually.&nbsp; </p>
<h3>Methods</h3>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
    <tr>
        <td width="168" valign="top">createBNode()</td>
        <td width="591"><p>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. &nbsp; </p></td>
    </tr>
    <tr>
        <td valign="top">createLiteral()</td>
        <td>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. &nbsp;</td>
    </tr>
    <tr>
        <td valign="top">createStatement()</td>
        <td>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. </td>
    </tr>
    <tr>
        <td valign="top">createURI()</td>
        <td>See <a href="#RepositoryConnection Class">RepositoryConnection</a> class. </td>
    </tr>
</table>
<p></p>
<p>&nbsp;   </p>
</body>

