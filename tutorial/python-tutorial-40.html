<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Python API Tutorial for AllegroGraph 4.2</title>

<style type="text/css">

.input { margin-left:4em; background-color:#ADDFFF;}
.output { margin-left:4em; background-color:#F1F1F1;}
.returnlink {font-size:small;  font-weight:normal; }
</style>
</head>
<body>
<h1>Python Sesame API Tutorial for AllegroGraph 4.2</h1>
<p>This is an introduction to the Python client API to AllegroGraph RDFStore&#8482; version 4.2 from <a href="http://agraph.franz.com/allegrograph/">Franz Inc.</a> </p>
<p>
The Python Sesame API offers convenient and efficient
access to an AllegroGraph server from a Python-based application.  This API provides methods for
creating, querying and maintaining RDF data, and for managing the stored triples. </p>
<p>The Python Sesame API deliberately emulates the Aduna Sesame API to make it easier to migrate from Sesame to AllegroGraph.&nbsp; The Python Sesame API has also been extended in ways that make it easier and more intuitive than the Sesame API.&nbsp; </p>
<h2 id="Contents">Contents</h2>
<table width="554" border="0" style="vertical-align:top" >
  <tr>
    <td width="249"><ul>
      <li><a href="#Overview">Overview</a></li>
<!--      <li><a href="#PrerequisitesWindows">Prerequisites (Windows)</a> </li>
-->      <li><a href="#PrerequisitesLinux">Prerequisites (Linux)</a></li>
      <li><a href="#Terminology">Terminology</a></li>
	  <li><a href="#Creating Users with WebView">Creating Users with WebView</a></li>
      <li><a href="#Running Python">Running Python Tutorial Examples</a></li>
      <li><a href="#Creating a Repository">Creating a Repository and Triple Indices </a></li>
      <li><a href="#Asserting and Retracting Triples">Asserting and Retracting Triples</a></li>
      <li><a href="#A SPARQL Query">A SPARQL Query</a></li>
      <li><a href="#Statement Matching">Statement Matching</a></li>
      <li><a href="#Literal Values">Literal Values</a></li>
      <li><a href="#Importing Triples">Importing Triples</a></li>
	  <li><a href="#Exporting Triples">Exporting Triples</a></li>      
      <li><a href="#Datasets and Contexts">Searching Multiple Graphs </a></li>
    </ul></td>
    <td width="295"><ul>
      <li><a href="#Namespaces">Namespaces</a></li>
      <li><a href="#Free Text Search">Free Text Search</a></li>
      <li><a href="#Ask, Describe, and Construct Queries">Select, Ask, Describe, and Construct Queries</a></li>
      <li><a href="#Parametric Queries">Parametric Queries</a></li>
      <li><a href="#Range Matches">Range Matches</a></li>
      <li><a href="#Federated Repositories">Federated Repositories</a></li>  
	  <li><a href="#Prolog Rule Queries">Prolog Rule Queries</a></li>
      <li><a href="#Loading Prolog Rules">Loading Prolog Rules</a> </li>
      <li><a href="#RDFS++ Inference">RDFS++ Inference</a> </li>
      <li><a href="#Geospatial Search">Geospatial Search</a> </li>
      <li><a href="#Social Network Analysis">Social Network Analysis</a> </li>
      <li><a href="#Transaction Control">Transaction Control</a></li>
      <li><a href="#Duplicate Triples">Duplicate Triples</a></li>
    <p>&nbsp;</p></td>
  </tr>
</table>
<p>&nbsp;</p>
<h2 id="Overview">Overview&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The Python client tutorial rests on a simple architecture involving AllegroGraph, disk-based data files, Python, and a file of Python examples called tutorial_examples_40.py.</p>
<table width="944" border="0">
  <tr>
    <td width="309"><p>AllegroGraph 4.1 Server contains the Python API, which is part of the AllegroGraph installation. </p>
    <p>Python communicates with AllegroGraph through HTTP port 8080 in this example. Python and AllegroGraph may be installed on the same computer, but in practice one server is shared by multiple clients. </p>
    <p>Load tutorial_examples_40.py into Python to view the tutorial examples. </p></td>
    <td width="625"><img src="allegrographdiagram.jpg" width="617" height="412"></td>
  </tr>
</table>
<p>Each lesson in <strong>tutorial_examples_40.py</strong> is encapsulated in a Python function, named exampleN(), where N ranges from 0 to 21 (or more). The function names are referenced in the title of each section to make it easier to compare the tutorial text and the living code of the examples file. </p>
<!-- Commented out until new procedures become clear. 
<h2 id="PrerequisitesLinux">Prerequisites (Windows) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<table border="1">
    <tr>
        <td width="867">The following procedure describes the installation of both the paid and free versions of AllegroGraph Server. Note that you cannot install both versions on the same computer. Follow the instructions that are appropriate to your version. </td>
    </tr>
</table>

<p>The tutorial examples can be run on a 32-bit Windows XP computer, running AllegroGraph and Python on the same computer (&quot;localhost&quot;). The tutorial assumes that AllegroGraph and Python 2.5 have  been installed and configured using this procedure:</p>
<p>&nbsp;</p>
<ol>
  <li>Download an AllegroGraph 4.0 installation file (agraph-4.0-windows.exe). The free edition is available <a href="http://www.franz.com/downloads/clp/ag_survey">here.</a> For the licensed edition please contact <a href="mailto:support@franz.com">Franz customer support</a> for a download link and authorizing key. </li>
  <li>Run the agraph-4.0-windows.exe to install AllegroGraph. The default installation directory is C:\Program Files\AllegroGraphFJE32 for the free edition, or c:\Program Files\AllegroGraphJEE32 for the licensed edition.</li>
  <li>Create a scratch directory for AllegroGraph to use for disk-based data storage. In this tutorial the directory is c:\tmp\scratch. If you elect to use a different location, the configuration and example files will have to be modified in the same way.</li>
  <li>
  Edit the <strong>agraph.cfg</strong> configuration file. You'll find it in the AllegroGraph installation directory. Set the following parameters to the indicated values. 
      <pre>:new-http-port 8080
:new-http-catalog ("c:/tmp/scratch")
:client-prolog t </pre>
  If you use a different port number, you will need to change the value of the AG_PORT variable at the top of tutorial_examples_40.py.
 It defaults to 8080. <br>
 <br>
 NOTE: On Windows Vista and Windows 7 systems, you must edit this file with elevated privileges. To do this, either start a Command Prompt with&nbsp; the context menu item &quot;Run as Administrator&quot; then edit the file using a text editor launched in that shell, or run your favorite editor with &quot;Run as Administrator&quot;. If you do not edit with elevated privileges, the file will look like it was saved successfully but the changes will not be seen by the service when it is started. This produces a &quot;cannot connect to server&quot; error message. 
  <li>To update AllegroGraph Server with recent patches, open a connection to the Internet. Run <strong>update.exe</strong>, which you will find the AllegroGraph installation directory. This automatically downloads and installs all current patches. </li>
  <li>On a Windows computer, the AllegroGraph Server runs as a Windows service. You have to restart this service to load the updates. Beginning at the Windows <strong>Start </strong>button, navigate this path: <br>
    <br>
  Start &gt; Settings &gt; Control Panel &gt; Administrative Tools &gt; Services. <br>
  <br>
  Locate the AllegroGraph Server service and select it. Click the <strong>Restart</strong> link to restart the service. </li>
  <li>This example used ActivePython 2.5 from ActiveState.com. Download and install the Windows installation file, 

 
  <a href="http://downloads.activestate.com/ActivePython/windows/2.5/ActivePython-2.5.2.2-win32-x86.msi">ActivePython-2.5.2.2-win32-x86.msi.</a> The default installation direction is C:\Python25.</li>
  <li>It is necessary to augment Python 2.5 with the CJSON package from python.cs.hu. Download and run the installation file, 

 
  <a href="http://python.cx.hu/python-cjson/python-cjson-1.0.3x6.win32-py2.5.exe">python-cjson-1.0.3x6.win32-py2.5.exe.</a> It will add files to the default Python directory structure.</li>
  <li>It is also necessary to augment Python 2.5 with the Pycurl package. Download and run the installation file, 

 
  <a href="http://pycurl.sourceforge.net/download/pycurl-ssl-7.18.2.win32-py2.5.exe">pycurl-ssl-7.18.2.win32-py2.5.exe.</a> It will add a small directory to your default Python directory structure. </li>
  <li>
    Link the Python software to the AllegroGraph Python API by setting a PYTHONPATH environment variable. For the free edition of AllegroGraph, the path value is:
      <pre>PYTHONPATH=C:\Program Files\AllegroGraphFJE40\python</pre>
For the licensed edition of AllegroGraph, the path value is:
      <pre>PYTHONPATH=C:\Program Files\AllegroGraphJEE40\python</pre>
In Windows XP, you can set an environment variable by 


 right-clicking on the <strong>My Computer</strong> icon, then navigate to Properties &gt; Advanced tab &gt; Environment Variables. Create a new variable showing the path to the AllegroGraph python subdirectory.<br>
 <br>
 <img src="environmentvariable.jpg" width="423" height="205"> <br>
  </li>
  <li>Start the ActivePython 2.5 PythonWin editor. Navigate this path:  <strong>Start</strong> button &gt; Programs &gt; ActiveState ActivePython 2.5 &gt;  PythonWin Editor. </li>
  <li>In the PythonWin editor, open the File menu, select Run, and browse to the location of the tutorial_examples_40.py file. It will be in the AllegroGraph\python subdirectory. Run this file. This loads and runs the Python tutorial examples.</li>
</ol>
-->
<h2 id="PrerequisitesLinux">Prerequisites (Linux) &nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The tutorial examples can be run on a Linux system, running AllegroGraph and the examples on the same computer (&quot;localhost&quot;). The tutorial assumes that AllegroGraph and Python 2.5 have been installed and configured using the procedure posted on <a href="http://www.franz.com/agraph/support/documentation/4.0/server-installation.html">this webpage</a>. </p>
<h2 id="Terminology">Terminology&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>We need to clarify some terminology before proceeding. </p>
<ul>
  <li>&quot;RDF&quot; is the <a href="http://www.w3.org/RDF/">Resource Description Framework</a> defined by the <a href="http://www.w3.org/">World Wide Web Consortium</a> (W3C). It provides a elegantly simple means for describing multi-faceted resource objects and for linking them into complex relationship graphs. AllegroGraph Server creates, searches, and manages such RDF graphs. </li>
  <li>A &quot;URI&quot; is a <a href="http://www.isi.edu/in-notes/rfc2396.txt">Uniform Resource Identifier</a>. It is label used to uniquely identify variosu types of entities in an RDF graph. A typical URI looks a lot like a web address: &lt;http:\\www.company.com\project\class#number&gt;. In spite of the resemblance, a URI is not a web address. It is simply a unique label. </li>
  <li>A &quot;triple&quot; is a data statement, a &quot;fact,&quot; stored in RDF format. It states that a  resource has an attribute with a value. It consists of three fields:</li>
  <ul>  <li>Subject: The first field contains the URI that uniquely identifies the resource that this triple describes. </li>
  <li>Predicate: The second field contains the URI identifying a property of this resource, such as its color or size, or a relationship between this resource and another one, such as parentage or ownership. </li>
  <li>Object: The third field is the value of the property. It could be a literal value, such as &quot;red,&quot; or the URI of a linked resource. </li>
  </ul>
  <li>A &quot;quad&quot; is a triple with an added &quot;context&quot; field, which is used to divide the repository into &quot;subgraphs.&quot; This context or subgraph is just a URI label that appears in the fourth field of related triples. </li>
  <li>A &quot;quint&quot; is a quad with fifth field used for the &quot;tripleID.&quot; AllegroGraph Server implements all triples as quints behind the scenes. The fourth and fifth fields are often ignored, however, so we speak casually of &quot;triples,&quot; and sometimes of &quot;quads,&quot; when it would be more rigorous to call them all &quot;quints.&quot; </li>
  <li>A &quot;resource description&quot; is defined as a collection of triples that all have the same URI in the subject field. In other words, the triples all describe attributes of the same thing.</li>
  <li>A &quot;statement&quot; is a client-side Python object that describes a triple (quad, quint).&nbsp; </li>
</ul>
  <table width="809" border="0">
  <tr>
    <td width="378"><p>In the context of AllegroGraph Server: </p>
      <ul>
        <li>A &quot;catalog&quot; is a list of repositories owned by an AllegroGraph server.</li>
        <li>A &quot;repository&quot; is a collection of triples within a Catalog, stored and indexed on a hard disk.</li>
        <li>A &quot;context&quot; is a subgraph of the triples in a repository. </li>
        <li>If contexts are not in use, the triples are stored in the background (default) graph. </li>
      </ul>      </td>
    <td width="421"><img src="catalogrepositorycontext.jpg" width="397" height="400" align="right"></td>
  </tr>
</table>
  <h2 id="Creating Users with WebView">Creating Users with WebView &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
  <p>Each connection to an AllegroGraph server runs under the credentials of a registered AllegroGraph user account. </p>
  <h3>Initial Superuser Account </h3>
  <p>The installation instructions for AllegroGraph advise you to create a default <strong>superuser</strong> called &quot;test&quot;, with password &quot;xyzzy&quot;. This is the user (and password) expected by the tutorial examples. If you created this account as directed, you can proceed to the <a href="#Creating a Repository">next section</a> and return to this topic at a later time when you need to create non-superuser accounts. </p>
  <p>If you created a different superuser account you'll have to edit the <strong>tutorial_examples_40.py</strong> file before proceeding. Modify these entries near the top of the file:</p>
  <pre class="input">AG_USER = 'test'<br>AG_PASSWORD = 'xyzzy' </pre>
  
  <p>Otherwise you'll get an authentication failure when you attempt to connect to the server. </p>
  <h3>Users, Permissions, Access Rules, and Roles</h3>
  <p>AllegroGraph user accounts may be given any combination of the following three permissions:</p>
  <ul>
    <li>Superuser</li>
    <li>Start Session</li>
    <li>Evaluate Arbritray Code</li>
  </ul>
  <p>In addition, a user account may be given read, write or read/write access to individual repositories. </p>
  <p>You can also define a <strong>role</strong> (such as &quot;librarian&quot;) and give the role a set of permissions and access rules. Then you can assign several users to a shared role. This lets you manage their permissions and access by editing the role instead of the individual user accounts. </p>
  <p>A <strong>superuser</strong> automatically has all possible permissions and unlimited access. A superuser can also create, manage and delete other user accounts. Non-superusers cannot view or edit account settings. </p>
  <p>A user with the <strong>Start Sessions</strong> permission can use the AllegroGraph features that require spawning a dedicated session, such as <a href="#Transaction Control">Transactions </a> and <a href="#Social Network Analysis">Social Network Analysis</a>. If you try to use these features without the appropriate permission, you'll encounter authentication errors. </p>
  <p>A user with permission to <strong>Evaluate Arbitrary Code </strong>can run <a href="#Prolog Rule Queries">Prolog Rule Queries</a>. This user can also do anything else that allows executing Lisp code, such as defining select-style generators, or doing eval-in-server, as well as loading server-side files. </p>
  <h3>WebView</h3>
  <p>WebView is AllegroGraph's HTTP-based graphical user interface for user and repository management. It provides a SPARQL endpoint for querying your triple stores as well as various tools that let you create and maintain triple stores interactively. </p>
  <p>To connect to WebView, simply direct your Web browser to the AllegroGraph port of your server. If you have installed AllegroGraph locally (and used the default port number), use:</p>
  <pre class="output">http://localhost:10035</pre>
  <p>You will be asked to log in. Use the superuser credentials described in the previous section. </p>
  <p>The first page of WebView is a summary of your catalogs, repositories, and federations. Click the <strong>user account</strong> link in the lower left corner of the page. This exposes the <strong>Users and Roles</strong> page.</p>
  <p><img src="webviewUser1.jpg" width="668" height="340"> </p>
  <p>This is the environment for creating and managing user accounts. </p>
    <p>To create a new user, click the [add a user] link. This exposes a small form where you can enter the username (one symbol) and password. Click OK to save the new account.</p>
    <p>The new user will appear in the list of users. Click the [view permissions] link to open a control panel for the new user account:</p>
    <p><img src="webviewNewUser.jpg" width="658" height="171"> </p>
    <p>Use the checkboxes to apply permissions to this account (superuser, start session, evaluate arbitrary code). </p>
    <p>It is imporant that you set up access permissions for the new user. Use the form to create an access rule by selecting read, write or read/write access, naming a catalog (or * for all), and naming a repository within that catalog (or * for all). Click the [add] link. This creates an access rule for your new user. The access rule will appear in the permissions display:</p>
    <p><img src="webviewAccessRule.jpg" width="629" height="196"> </p>
    <p>This new user can log in and perform transactions on any repository in the system. </p>
    <p>To repeat, the &quot;test&quot; superuser is all you need to run all of the tutorial examples. This section is for the day when you want to issue more modest credentials to some of your operators. </p>
    <h2 id="Running Python">Running Python Tutorial Examples &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
    <p>The AllegroGraph Python Tutorial examples are in the<strong> tutorial </strong>subdirectory where you unpacked the Python client tar.gz file. Navigate to that directory and follow one of these examples:</p>
    <pre>     $ python tutorial_examples_40.py            runs all tests.
     $ python tutorial_examples_40.py all        runs all tests.
     $ python tutorial_examples_40.py 10         runs example10()
     $ python tutorial_examples_40.py 1 5 22     runs examples 1, 5, and 22</pre>

    <h2 id="Creating a Repository">Creating a Repository and Triple Indices (example1()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
    <p>The first task is to attach to our AllegroGraph Server and open a repository. This task is implemented in<strong> example1()</strong> from<strong> tutorial_examples_40.py</strong>. </p>
<p>In <strong>example1()</strong> we build a chain of Python objects,  ending in a&quot;connection&quot; object that lets us manipulate triples in a specific repository. The overall process of generating the connection object follows 
this diagram:</p>
  <table width="809" border="0">
  <tr>
    <td width="378"><p>The example1() function opens (or creates) a repository by building a series of client-side objects, culminating in a &quot;connection&quot; object. The connection object will be passed to other functions in tutorial_examples_40.py. </p>
      <p>The connection object contains the methods that let us manipulate triples in a specific repository. </p></td>
    <td width="421"><img src="createconnectionobject.jpg" width="448" height="212"></td>
  </tr>
</table>

<p>The example first connects to an AllegroGraph Server by providing the endpoint (host IP address and port number) of an already-launched AllegroGraph server. This creates a client-side server object, which can access the AllegroGraph server's list of available catalogs through the <strong>listCatalogs()</strong> method:. </p>
<pre class="input">def example1(accessMode=Repository.RENEW):
    server = AllegroGraphServer(AG_HOST, AG_PORT, 'user', 'password')
    print &quot;Available catalogs&quot;, server.listCatalogs()
</pre>
<p>This is the output so far:</p>
<pre class="output">&gt;&gt;&gt; example1()
Defining connnection to AllegroGraph server -- host:'localhost' port:8080
Available catalogs ['/', 'scratch']</pre>
<p>This output says that the server has two catalogs, the default <strong>rootCatalog, '/'</strong>, and a named catalog 'scratch' that someone has created for some experimentation.</p>
<p>In the next line of example1(), we use the <strong>server.openCatalog()</strong> method to create a client-side catalog object. In this example we will connect to the default rootCatalog by calling openCatalog() with no arguments. When we look inside the root catalog, we can see which repositories are available:</p>
<pre class="input">
    catalog = server.openCatalog() 
    print &quot;Available repositories in catalog '%s': %s&quot; % (catalog.getName(), catalog.listRepositories()) </pre>
<p>The corresponding output lists the available repositories.  (When you run the examples, you may see a different list of repositories.)</p>
<pre class="output">Available repositories in catalog 'None': ['tutorial']  </pre>
<p>The next step is to create a client-side repository object representing the respository we wish to open, by calling the
<strong>getRepository()</strong> method of the catalog object. We have to provide the name of the desired repository (<strong>AG_REPOSITORY,</strong> bound to <strong>python-tutorial </strong> in this case), and select one of four access modes:</p>
<ul>
  <li><strong>Repository.RENEW</strong> clears the contents of an existing repository before opening. If the indicated repository does not exist, 
  it creates one. </li>
  <li><strong>Repository.OPEN</strong> opens an existing repository, or throws an exception if the repository is not found. </li>
  <li><strong>Repository.ACCESS</strong> opens an existing repository, or creates a new one if the repository is not found.</li>
  <li><strong>Repository.CREATE</strong> creates a new repository, or throws an exception if one by that name already exists.</li>
</ul>
<p>Repository.RENEW is the default setting for the example1() function of tutorial_examples_40.py. It can be overridden by calling 
  example1() with the appropriate argument, such as example1(Repository.OPEN).</p>
<pre class="input">
    myRepository = catalog.getRepository(AG_REPOSITORY, accessMode)
    myRepository.initialize()</pre>
<p>A new or renewed repository must be initialized, using the <strong>initialize()</strong> method of the repository object. If you try to initialize a respository twice you get a warning message in the Python window but no exception. </p>
<p>The goal of all this object-building has been to create a client-side connection object, whose methods let us manipulate the triples of the repository. The repository object's <strong>getConnection()</strong> method returns this connection object. </p>
<pre class="input">
    connection = myRepository.getConnection()
    print &quot;Repository %s is up! It contains %i statements.&quot; % (
    myRepository.getDatabaseName(), connection.size())
</pre>
 <p>The <strong>size()</strong> method of the connection object returns how many triples are present. In the example1() function, this number should always be zero because we &quot;renewed&quot; the repository. This is the output in the Python window: </p>
<pre class="output">   Repository pythontutorial is up! It contains 0 statements.
   &lt;franz.openrdf.repository.repositoryconnection.RepositoryConnection object at 0x0127D710&gt;
 &gt;&gt;&gt; </pre>
<p>Whenever you create a new repository, you should stop to consider which kinds of triple indices you will need.&nbsp; This is an important efficiency decision.&nbsp; AllegroGraph uses a set of sorted indices to quickly identify a contiguous block of triples that are likely to match a specific query pattern. </p>
<p>These indices are identified by names that describe their organization. The default set of indices are called <strong>spogi, posgi, ospgi, gspoi, gposi, gospi</strong>, and<strong> i</strong> , where: </p>
<ul>
    <li>S stands for the subject URI. </li>
    <li>P stands for the predicate URI. </li>
    <li>O stands for the object URI or literal. </li>
    <li>G stands for the graph URI. </li>
    <li>I stands for the triple identifier (its unique id number within the triple store). </li>
</ul>
<p> The order of the letters denotes how the index has been organized. For instance, the <strong>spogi</strong> index contains all of the triples in the store, sorted first by subject, then by predicate, then by object, and finally by graph. The triple id number is present as a fifth column in the index. If you know the URI of a desired resource (the <em>subject</em> value of the query pattern), then the <strong>spogi</strong> index lets you retrieve all triples with that subject as a single block.&nbsp; </p>
<p>The idea is to provide your respository with the indices that your queries will need, and to avoid maintaining indices that you will never need.&nbsp; </p>
<p>We can use the connection object's <strong>listValidIndices()</strong> method to examine the list of all possible AllegroGraph triple indices: </p>
<pre class="input">    indices = conn.listValidIndices()<br>    print &quot;All valid triple indices: %s&quot; % (indices)</pre>
<p>This is the list of all possible valid indices:</p>
<pre class="output">All valid triple indices: ['spogi', 'spgoi', 'sopgi', 'sogpi', 'sgpoi', 'sgopi', 
'psogi', 'psgoi', 'posgi', 'pogsi', 'pgsoi', 'pgosi', 'ospgi', 'osgpi', 'opsgi', 
'opgsi', 'ogspi', 'ogpsi', 'gspoi', 'gsopi', 'gpsoi', 'gposi', 'gospi', 'gopsi', 'i']</pre>
<p>AllegroGraph can generate any of these indices if you need them, but it creates only seven indices by default.&nbsp; We can see the current indices by using the connection object's <strong>listIndices()</strong> method:</p>
<pre class="input">    indices = conn.listIndices()<br>    print &quot;Current triple indices: %s&quot; % (indices)</pre>
<p>There are currently seven indices:</p>
<pre class="output">Current triple indices: ['i', 'gospi', 'gposi', 'gspoi', 'ospgi', 'posgi', 'spogi']</pre>
<p>The indices that begin with &quot;g&quot; are sorted primarily by subgraph (or &quot;context&quot;).&nbsp; If you application does not use subgraphs, you should consider removing these indices from the repository.&nbsp; You don't want to build and maintain triple indices that your application will never use.&nbsp; This wastes CPU time and disk space.&nbsp; The connection object has a convenient <strong>dropIndex()</strong> method:</p>
<pre class="input">    print &quot;Removing graph indices...&quot;<br>    conn.dropIndex(&quot;gospi&quot;)<br>    conn.dropIndex(&quot;gposi&quot;)<br>    conn.dropIndex(&quot;gspoi&quot;)<br>    indices = conn.listIndices()<br>    print &quot;Current triple indices: %s&quot; % (indices)</pre>
<p>Having dropped three of the triple indices, there are now four remaining:</p>
<pre class="output">Removing graph indices...<br>Current triple indices: ['i', 'ospgi', 'posgi', 'spogi']</pre>
<p>The <strong>i</strong> index is for deleting triples by using the triple id number.&nbsp; The <strong>ospgi</strong> index is sorted primarily by object value, which makes it possible to grab a range of object values as a single block of triples from the index.&nbsp; Similarly, the <strong>posgi</strong> index lets us reach for a block of triples that all share the same predicate.&nbsp; We mentioned previously that the <strong>spogi</strong> index lets us retrieve blocks of triples that all have the same subject URI.&nbsp; </p>
<p>As it happens, we may have been overly hasty in eliminating all of the graph indices.&nbsp; AllegroGraph can find the right matches as long as there is <em>any</em> one index present, but using the &quot;right&quot; index is much faster.&nbsp; Let's put one of the graph indices back, just in case we need it. We'll use the connection object's<strong> addIndex()</strong> method: </p>
<pre class="input">    print &quot;Adding one graph index back in...&quot;<br>    conn.addIndex(&quot;gspoi&quot;)<br>    indices = conn.listIndices()<br>    print &quot;Current triple indices: %s&quot; % (indices)
    return conn</pre>
<pre class="output">Adding one graph index back in...<br>Current triple indices: ['i', 'gspoi', 'ospgi', 'posgi', 'spogi']</pre>
<p>The last line (return conn) is the pointer to the new connection object. This is the value returned by example1() when it is called by other functions in tutorial_examples_40.py. The other functions then use the connection object to access the repository. </p>
<h2 id="Asserting and Retracting Triples">Asserting and Retracting Triples (example2()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>




<p>

In example example2(), we show how
to create resources describing two
people, Bob and Alice, by asserting individual triples into the respository. The example also retracts and replaces a triple.  Assertions and retractions to the triple store
are executed by 'add' and 'remove' methods belonging to the connection object, which we obtain by calling the example1() function (described above).
</p>
<p>Before asserting a triple, we have to generate the URI values for the subject, predicate and object fields. The Python Sesame API to AllegroGraph Server predefines a number of classes and predicates for the RDF, RDFS, XSD, and OWL ontologies.  RDF.TYPE is one of the predefined predicates we will use. </p>
<p>
The 'add' and 'remove' methods take an optional 'contexts' argument that
specifies one or more subgraphs that are the target of triple assertions
and retractions.  When the context is omitted, triples are asserted/retracted
to/from the background graph.  In the example below, facts about Alice and Bob
reside in the background graph.
</p>
<p>The example2() function begins by calling example1() to create the appropriate connection object, which is bound to the variable <strong>conn</strong>. </p>
<pre class="input">def example2():
    conn = example1()
</pre>
 <p>The next step is to begin assembling the URIs we will need for the new triples. The createURI() method generates a URI from a string. These are the subject URIs identifying the resources &quot;Bob&quot; and &quot;Alice&quot;:</p>
 <pre class="input">
    alice = conn.createURI(&quot;http://example.org/people/alice&quot;)
    bob = conn.createURI(&quot;http://example.org/people/bob&quot;)
</pre>
 <p>Bob and Alice will be members of the &quot;person&quot; class (RDF:TYPE person). </p>
 <pre class="input">    person = conn.createURI(&quot;http://example.org/ontology/Person&quot;)
</pre>
 <p>Both Bob and Alice will have a &quot;name&quot; attribute. </p>
 <pre class="input">    name = conn.createURI(&quot;http://example.org/ontology/name&quot;)
</pre>
 <p>The name attributes will contain literal values. We have to generate the Literal objects from strings: </p>
 <pre class="input">    bobsName = conn.createLiteral(&quot;Bob&quot;)
    alicesName = conn.createLiteral(&quot;Alice&quot;)</pre>
 <p>The next line prints out the number of triples currently in the repository. </p>
 <pre class="input">
    print "Triple count before inserts: ", conn.size()
</pre>
<pre class="output">Triple count before inserts:  0
</pre>
<p>Now we assert four triples, two for Bob and two more for Alice, using the connection object's <strong>add()</strong> method. After the assertions, we count triples again (there should be four) and print out the triples for inspection. </p>
<pre class="input">    ## alice is a person
    conn.add(alice, RDF.TYPE, person)
    ## alice's name is "Alice"
    conn.add(alice, name, alicesName)
    ## bob is a person
    conn.add(bob, RDF.TYPE, person)
    ## bob's name is "Bob":
    conn.add(bob, name, bobsName)

    print "Triple count: ", conn.size()
    for s in conn.getStatements(None, None, None, None, False): print s </pre>
<p>The &quot;None&quot; arguments to the getStatements() method say that we don't want to restrict what values may be present in the subject, predicate, object or context positions. Just print out all the triples. </p>
<p>This is the output at this point. We see four triples, two about Alice and two about Bob:</p>
<pre class="output">
Triple count:  4
(&lt;http://example.org/people/alice&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/ontology/Person&gt;)
(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/ontology/name&gt;, "Alice")
(&lt;http://example.org/people/bob&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/ontology/Person&gt;)
(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/ontology/name&gt;, "Bob")</pre>
<p>We see two resources of type &quot;person,&quot; each with a literal name. </p>
<p>The next step is to demonstrate how to remove a triple. Use the remove() method of the connection object, and supply a triple pattern that matches the target triple. In this case we want to remove Bob's name triple from the repository. Then we'll count the triples again to verify that there are only three remaining. Finally, we re-assert Bob's name so we can use it in subsequent examples, and we'll return the connection object.. </p>
<pre class="input">
    conn.remove(bob, name, bobsName)
    print "Triple count: ", conn.size()
    conn.add(bob, name, bobsName)    
    return conn</pre>
 
 <pre class="output">
Triple count:  3
&lt;franz.openrdf.repository.repositoryconnection.RepositoryConnection object at 0x01466830&gt;</pre>
 
 <h2 id="A SPARQL Query">A SPARQL Query (example3()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>SPARQL stands for  the &quot;<a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL Protocol and RDF Query Language</a>,&quot; a recommendation of the <a href="http://www.w3.org/">World Wide Web Consortium (W3C)</a>. SPARQL is a query language for retrieving RDF triples. </p>
 <p>Our next example illustrates how to evaluate a SPARQL query. This is the simplest query, the one that returns all triples. Note that example3() continues with the four triples created in example2(). </p>
 <pre class="input">def example3():    
    conn = example2()
    try:
        queryString = "SELECT ?s ?p ?o  WHERE {?s ?p ?o .}"
</pre>
<p>The SELECT clause returns the variables ?s, ?p and ?o in the bindingSet. The variables are bound to the subject, predicate and objects values of each triple that satisfies the WHERE clause. In this case the WHERE clause is unconstrained. The dot (.) in the fourth position signifies the end of the pattern. </p>
<p>The connection object's prepareTupleQuery() method
  creates a query object that can be evaluated one or more times. (A &quot;tuple&quot; is an ordered sequence of data elements in Python.)   The results are returned in an iterator that yields a sequence of bindingSets.</p>
<pre class="input">
        tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)
        result = tupleQuery.evaluate();
</pre>
<p>Below we illustrate one (rather heavyweight) method for extracting the values
  from a binding set, indexed by the name of the corresponding column variable
in the SELECT clause.</p>
<pre class="input">
        try:
            for bindingSet in result:
                s = bindingSet.getValue("s")
                p = bindingSet.getValue("p")
                o = bindingSet.getValue("o")              
                print "%s %s %s" % (s, p, o)
</pre>
<pre class="output">
http://example.org/people/alice http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://example.org/ontology/Person
http://example.org/people/alice http://example.org/ontology/name "Alice"
http://example.org/people/bob http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://example.org/ontology/Person
http://example.org/people/bob http://example.org/ontology/name "Bob"
</pre>
<p>The Connection class is designed to be created for the duration of a sequence of updates and queries, and then closed. In practice, many AllegroGraph applications keep a connection open indefinitely. However, best practice dictates that the connection should be closed, as illustrated below. The same hygiene applies to the iterators that generate binding sets.</p>
<pre class="input">        finally:<br>            result.close();<br>    finally:<br>        conn.close();<br>        myRepository = conn.repository<br>        myRepository.shutDown()</pre>
<h2 id="Statement Matching">Statement Matching (example4()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>

<p>
The getStatements() method of the connection object provides a simple way to perform unsophisticated queries. This method lets you enter a mix of required values and wildcards, and retrieve all matching triples. (If you need to perform sophisticated tests and comparisons you should use the SPARQL query instead.)</p>
<p>
Below, we illustrate two kinds of 'getStatement' calls.  The first mimics
traditional Sesame syntax, and returns a Statement object at each iteration. This is the <strong>example4()</strong> function of tutorial_examples_40.py. It begins by calling example2() to create a connection object and populate the <strong>pythontutorial</strong> repository with four triples describing Bob and Alice. We're going to search for triples that mention Alice, so we have to create an &quot;Alice&quot; URI  to use in the search pattern: </p>
<pre class="input">def example4():<br>    conn = example2()<br>    alice = conn.createURI(&quot;http://example.org/people/alice&quot;)
</pre>
<p> Now we search for triples with Alice's URI in the subject position.  The &quot;None&quot; values are wildcards for the predicate and object positions of the triple. </p>
<pre class="input">    print &quot;Searching for Alice using getStatements():&quot;
    statements = conn.getStatements(alice, None, None)
</pre>
<p>The getStatements() method returns a repositoryResult object (bound to the variable &quot;statements&quot; in this case). This object can be iterated over, exposing one result statement at a time. It is sometimes desirable to screen the results for duplicates, using the enableDuplicateFilter() method. Note, however, that duplicate filtering can be expensive. Our example does not contain any duplicates, but it is possible for them to occur. </p>
<pre class="input">    statements.enableDuplicateFilter() <br>    for s in statements:<br>        print s
</pre>
<p>This prints out the two matching triples for &quot;Alice.&quot; </p>
<pre class="output">Searching for Alice using getStatements():<br>(&lt;http://example.org/people/alice&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/ontology/Person&gt;)
(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/ontology/name&gt;, &quot;Alice&quot;) </pre>
<p>At this point it is good form to close the respositoryResponse object because they occupy memory and are rarely reused in most programs. </p>
<pre class="input">	statements.close()</pre>

<h2 id="Literal Values">Literal Values (example5())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The next example, <strong>example5()</strong>, illustrates some variations on what we have seen so far.  The example creates and asserts <a href="http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal">typed and plain literal values</a>, including  language-specific plain literals, and then conducts searches for them in three ways:</p>
<ul>
  <li>getStatements() search, which is an efficient way to match a single triple pattern. </li>
  <li>SPARQL direct match, for efficient multi-pattern search. </li>
  <li>SPARQL filter match, for sophisticated filtering such as performing range matches. </li>
</ul>
<p>The getStatements() and SPARQL direct searches return exactly the datatype you ask for. The SPARQL filter queries can sometimes return multiple datatypes. This behavior will be one focus of this section. </p>
<p>If you are not explicit about the datatype of a value, either when asserting the triple or when writing a search pattern, AllegroGraph will deduce an appropriate datatype and use it. This is another focus of this section. This helpful behavior can sometimes surprise you with unanticipated results. </p>
<h3>Setup</h3>
<p>Example5() begins by obtaining a connection object from example1(), and then clears the repository of all existing triples. </p>
<pre class="input">def example5():<br>    conn = example1()<br>    conn.clear()
</pre>
<p>For sake of coding efficiency, it is good practice to create variables for namespace strings. We'll use this namespace again and again in the following lines. We have made the URIs in this example very short to keep the result displays compact.</p>
<pre class="input">    exns = &quot;http://people/&quot;
</pre>
<p>The example creates new resources describing seven people, named alphabetically from Alice to Greg. These are URIs to use in the subject field of the triples. The example shows how to enter a full URI string, or alternately how to combine a namespace with a local resource name. </p>
<pre class="input">    alice = conn.createURI(&quot;http://example.org/people/alice&quot;)<br>    bob = conn.createURI(&quot;http://example.org/people/bob&quot;)<br>    carol = conn.createURI(&quot;http://example.org/people/carol&quot;)<br>    dave = conn.createURI(namespace=exns, localname=&quot;dave&quot;)<br>    eric = conn.createURI(namespace=exns, localname=&quot;eric&quot;)<br>    fred = conn.createURI(namespace=exns, localname=&quot;fred&quot;)
    greg = conn.createURI(namesapce=exns, localname=&quot;greg&quot;)</pre>
<h3>Numeric Literal Values </h3>
<p>This section explores the behavior of numeric literals.</p>
<h3>Asserting Numeric Data</h3>
<p>The first section assigns ages to the participants, using a variety of numeric types. First we need a URI for the &quot;age&quot; predicate. </p>
<pre class="input">    age = conn.createURI(namespace=exns, localname=&quot;age&quot;)</pre>
<p>The next step is to create a variety of values representing ages. Coincidentally, these people are all 42 years old, but we're going to record that information in multiple ways:</p>
<pre class="input">    fortyTwo = conn.createLiteral(42)             # creates long
    fortyTwoDouble = conn.createLiteral(42.0)    # creates double
    fortyTwoInt = conn.createLiteral('42', datatype=XMLSchema.INT)
    fortyTwoLong = conn.createLiteral('42', datatype=XMLSchema.LONG) 
    fortyTwoFloat = conn.createLiteral('42', datatype=XMLSchema.FLOAT) 
    fortyTwoString = conn.createLiteral('42', datatype=XMLSchema.STRING)
    fortyTwoPlain = conn.createLiteral('42')      # creates plain literal</pre>
<p>In four of these statements, we explicitly identified the datatype of the value in order to create an INT, a LONG,  a FLOAT and a STRING. This is the best practice. </p>
<p>In three other statements, we just handed AllegroGraph numeric-looking values to see what it would do with them. As we will see in a moment, 42 creates a LONG, 42.0 becomes into a DOUBLE, and '42' becomes a &quot;plain&quot; (untyped) literal value. (Note that plain literals are not <em>quite </em>the same thing as typed literal strings. A search for a plain literal will not always match a typed string, and <em>vice versa</em>.)</p>
<p>Now we need to assemble the URIs and values into statements (which are client-side triples):</p>
<pre class="input">    stmt1 = conn.createStatement(alice, age, fortyTwo)
    stmt2 = conn.createStatement(bob, age, fortyTwoDouble)    
    stmt3 = conn.createStatement(carol, age, fortyTwoInt)    
    stmt4 = conn.createStatement(dave, age, fortyTwoLong)    
    stmt5 = conn.createStatement(eric, age, fortyTwoFloat)
    stmt6 = conn.createStatement(fred, age, fortyTwoString)  
    stmt7 = conn.createStatement(greg, age, fortyTwoPlain)</pre>
<p>And then add the statements to the triple store on the AllegroGraph server. We can use either <strong>add()</strong> or <strong>addStatement()</strong> for this purpose. </p>
<pre class="input">    conn.add(stmt1)
    conn.add(stmt2)
    conn.add(stmt3)
    conn.addStatement(stmt4)
    conn.addStatement(stmt5)
    conn.addStatement(stmt6)
    conn.addStatement(stmt7)
</pre>
<p>Now we'll complete the round trip to see what triples we get back from these assertions. This is how we use <strong>getStatements()</strong> in this example to retrieve and display triples for us:</p>
<pre class="input">    print "\nShowing all age triples using getStatements(). Seven matches."
    statements = conn.getStatements(None, age, None)
    for s in statements:
        print s</pre>
<p>This loop prints all age triples to the interaction window. Note that the retrieved triples are of six types: two ints, a long, a float, a double, a string, and a &quot;plain literal.&quot; All of them say that their person's age is 42. Note that the triple for Greg has the plain literal value &quot;42&quot;, while the triple for Fred uses &quot;42&quot; as a typed string.</p>
<pre class="output">Showing all age triples using getStatements(). Seven matches.<br>(&lt;http://people/greg&gt;, &lt;http://people/age&gt;, &quot;42&quot;)<br>(&lt;http://people/fred&gt;, &lt;http://people/age&gt;, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;)<br>(&lt;http://people/eric&gt;, &lt;http://people/age&gt;, &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;)<br>(&lt;http://people/dave&gt;, &lt;http://people/age&gt;, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;)<br>(&lt;http://people/carol&gt;, &lt;http://people/age&gt;, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;)<br>(&lt;http://people/bob&gt;, &lt;http://people/age&gt;, &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;)<br>(&lt;http://people/alice&gt;, &lt;http://people/age&gt;, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;)</pre>
<p>If you ask for a specific datatype, you will get it. If you leave the decision up to AllegroGraph, you might get something unexpected such as an plain literal value. </p>
<h3>Matching Numeric Data</h3>
<p>This section explores getStatements() and SPARQL matches against numeric triples. </p>
<p>In the first example, we asked AllegroGraph to find an untyped number, <strong>42.</strong> </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, 42)</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;    </td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p 42 .}</td>
    <td>No direct matches. </td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = 42)}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>      &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;<br>      
    &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;<br>    &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;</td>
  </tr>
</table>
<p>The getStatements() query returned triples containing longs only. The SPARQL direct match didn't know how to interpret the untyped value and found zero matches. The SPARQL filter match, however, opened the doors to matches of multiple numeric types, and returned ints, floats, longs and doubles. </p>
<p><strong>&quot;Match 42.0&quot;</strong> without explicitly declaring the number's type.</p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, 42.0)</td>
    <td><p>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;<br>
      Matches a double but not a float. </p>    </td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p 42.0 .}</td>
    <td>No direct matches. </td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = 42.0)}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>      &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;<br>      &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;<br>    
    &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;</td>
  </tr>
</table>
<p>The getStatements() search returned a double but not the similar float. The filter match returned all numeric types that were equal to 42.0.</p>
<p><strong>&quot;Match '42'^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;.&quot;</strong> Note that we have to use a variable (fortyTwoInt) bound to a Literal value in order to offer this int to getStatements(). We can't just type the value into the getStatements() method directly. </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, fortyTwoInt)</td>
    <td><p>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>
      </p>    </td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;</td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;)}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>      &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;<br>      &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;<br>    
    &quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;</td>
  </tr>
</table>
<p>Both the getStatements() query and the SPARQL direct query returned exactly what we asked for: ints. The filter match returned all numeric types that matches in value. </p>
<p><strong>&quot;Match '42'^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;.&quot;</strong> Again we need a bound variable to offer a Literal value to getStatements(). </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, fortyTwoLong)</td>
    <td><p>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;<br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;</td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;)}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>
&quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;<br>
&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;<br>
&quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;</td>
  </tr>
</table>
<p>Both the getStatements() query and the SPARQL direct query returned longs. The filter match returned all numeric types. </p>
<p><strong>&quot;Match '42'^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;.&quot;</strong> </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, fortyTwoDouble)</td>
    <td><p>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;<br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;</td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;)}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>
&quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;<br>
&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;<br>
&quot;4.2E1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;</td>
  </tr>
</table>
<p>Both the getStatements() query and the SPARQL direct query returned doubles. The filter match returned all numeric types. </p>
<h3>Matching Numeric Strings and Plain Literals</h3>
<p>At this point we are transitioning from tests of numeric matches to tests of string matches, but there is a gray zone to be explored first. What do we find if we search for strings that contain numbers? In particular, what about &quot;plain literal&quot; values that are almost, but not quite, strings?</p>
<p><strong>&quot;Match '42'^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;.&quot;</strong> This example asks for a typed string to see if we get any numeric matches back. </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, fortyTwoString)</td>
    <td><p>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
      It did not match the plain literal. 
      <br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;}</td>
    <td><p>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>&quot;42&quot; This is the plain literal value. </p>    </td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;)}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
&quot;42&quot; This is the plain literal value. </td>
  </tr>
</table>
<p>The getStatements() query matched a literal string only. The SPARQL queries returned matches that were both typed strings and plain literals. There were no numeric matches. </p>
<p><strong>&quot;Match plain literal '42'.&quot;</strong> This example asks for a plain literal to see if we get any numeric matches back. </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, fortyTwoPlain)</td>
    <td><p>&quot;42&quot; This is the plain literal. It did not match the string. <br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;42&quot;}</td>
    <td><p>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
&quot;42&quot; This is the plain literal value. </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;42&quot;)}</td>
    <td>&quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
&quot;42&quot; This is the plain literal value. </td>
  </tr>
</table>
<p>The getStatements() query matched the plain literal only, and did not match the string. The SPARQL queries returned matches that were both typed strings and plain literals. There were no numeric matches. </p>
<p>The interesting lesson here is that AllegroGraph distinguishes between strings and plain literals when you use getStatements(), but it lumps them together when you use SPARQL. </p>
<h3>Matching Strings</h3>
<p>In this section we'll set up a variety of string triples and experiment with matching them using getStatements() and SPARQL. Note that <a href="#Free Text Search">Free Text Search</a> is a different topic. In this section we're doing simple matches of whole strings.</p>
<h3>Asserting String Values </h3>
<p>We're going to add a &quot;favorite color&quot; attribute to five of the person resources we have used so far. First we need a predicate.</p>
<pre class="input">    favoriteColor = conn.createURI(namespace=exns, localname="favoriteColor")
</pre>
<p>Now we'll create a variety of string values, and a single &quot;plain literal&quot; value. </p>
<pre class="input">    UCred = conn.createLiteral('Red', datatype=XMLSchema.STRING)<br>    LCred = conn.createLiteral('red', datatype=XMLSchema.STRING)<br>    RedPlain = conn.createLiteral('Red')                  #plain literal<br>    rouge = conn.createLiteral('rouge', datatype=XMLSchema.STRING)<br>    Rouge = conn.createLiteral('Rouge', datatype=XMLSchema.STRING)<br>    RougePlain = conn.createLiteral('Rouge')              #plain literal<br>    FrRouge = conn.createLiteral('Rouge', language=&quot;fr&quot;)  #plain literal with language tag</pre>
<p>Note that in the last line we created a plain literal and assigned it a French language tag. <em>You cannot assign a language tag to strings, only to plain literals.</em> See <a href="http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal">typed and plain literal values</a> for the specification.</p>
<p>Next we'll add these values to new triples in the triple store. For variety, we bypassed creating client-side statements and just asserted the triples in one step.</p>
<pre class="input">    conn.addTriples([(alice, favoriteColor, UCred),<br>                     (bob, favoriteColor, LCred),<br>                     (carol, favoriteColor, RedPlain),<br>                     (dave, favoriteColor, rouge),<br>                     (eric, favoriteColor, Rouge),<br>                     (fred, favoriteColor, RougePlain),<br>                     (greg, favoriteColor, FrRouge)])</pre>
<p>If we run a getStatements() query for all favoriteColor triples, we get these values returned:</p>
<pre class="input">(&lt;http://people/alice&gt;, &lt;http://people/favoriteColor&gt;, &quot;Red&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;)<br>(&lt;http://people/bob&gt;, &lt;http://people/favoriteColor&gt;, &quot;red&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;)<br>(&lt;http://people/carol&gt;, &lt;http://people/favoriteColor&gt;, &quot;Red&quot;)<br>(&lt;http://people/dave&gt;, &lt;http://people/favoriteColor&gt;, &quot;rouge&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;)<br>(&lt;http://people/eric&gt;, &lt;http://people/favoriteColor&gt;, &quot;Rouge&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;)<br>(&lt;http://people/fred&gt;, &lt;http://people/favoriteColor&gt;, &quot;Rouge&quot;)<br>(&lt;http://people/greg&gt;, &lt;http://people/favoriteColor&gt;, &quot;Rouge&quot;@fr)</pre>
<p>That's four typed strings, capitalized and lower case, plus three plain literals, one with a language tag. </p>
<h3>Matching String Data</h3>
<p>First let's search for &quot;Red&quot; without specifying a datatype. </p>
<p><strong>&quot;Match 'Red'.&quot;</strong> What happens if we search for &quot;Red&quot; without specifying a string datatype? </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, &quot;Red&quot;)</td>
    <td><p>&quot;Red&quot; This is the plain literal. It did not match the string. <br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;Red&quot;}</td>
    <td><p>&quot;Red&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
&quot;Red&quot; This is the plain literal value.</p>
    </td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;Red&quot;)}</td>
    <td>&quot;Red&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
&quot;Red&quot; This is the plain literal value.</td>
  </tr>
</table>
<p>The getStatements() query matched the plain literal only, and did not match the similar string. The SPARQL queries matched both &quot;Red&quot; typed strings and &quot;Red&quot; plain literals, but they did not return the lower case &quot;red&quot; triple. The match was liberal regarding datatype but strict about case. </p>
<p>Let's try &quot;Rouge&quot;.</p>
<p><strong>&quot;Match 'Rouge'.&quot;</strong> What happens if we search for &quot;Rouge&quot; without specifying a string datatype or language? Will it match the triple with the French tag? </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, &quot;Rouge&quot;)</td>
    <td><p>&quot;Rouge&quot; This is the plain literal. It did not match the string. <br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;Rouge&quot;}</td>
    <td><p>&quot;Rouge&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
&quot;Rouge&quot; This is the plain literal value.  <br>
Did not match the &quot;Rouge&quot;@fr triple. </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;Rouge&quot;)}</td>
    <td>&quot;Rouge&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>
&quot;Rouge&quot; This is the plain literal value.  <br>
Did not match the&quot;Rouge&quot;@fr triple. </td>
  </tr>
</table>
<p>The getStatements() query matched the plain literal only, and did not match the similar string. The SPARQL queries matched both &quot;Rouge&quot; typed strings and &quot;Rouge&quot; plain literals, but they did not return the &quot;Rouge&quot;@fr triple. The match was liberal regarding datatype but strict about language. We didn't ask for French, so we didn't get French. </p>
<p><strong>&quot;Match 'Rouge'@fr.&quot;</strong> What happens if we search for &quot;Rouge&quot;@fr? We'll have to bind the value to a variable (FrRouge) to use getStatements(). We can type the value directly into the SPARQL queries. </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, FrRouge)</td>
    <td><p>&quot;Rouge&quot;@fr <br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;Rouge&quot;@fr}</td>
    <td><p>&quot;Rouge&quot;@fr </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;Rouge&quot;@fr)}</td>
    <td>&quot;Rouge&quot;@fr </td>
  </tr>
</table>
<p>If you ask for a specific language, that's exactly what you are going to get, in all three types of queries. </p>
<p>You may be wondering how to perform a string match where language and capitalization don't matter. You can do that with a SPARQL filter query using the <strong>str()</strong> function, which strips out the string portion of a literal, leaving behind the datatype or language tag. Then the <strong>lowercase()</strong> function eliminates case issues:</p>
<pre class="input">PREFIX fn: &lt;http://www.w3.org/2005/xpath-functions#&gt; 
SELECT ?s ?p ?o 
WHERE {?s ?p ?o . filter (fn:lower-case(str(?o)) = &quot;rouge&quot;)}</pre>
<p>This query returns a variety of &quot;Rouge&quot; triples:</p>
<pre class="output">&lt;http://people/greg&gt; &lt;http://people/favoriteColor&gt; &quot;Rouge&quot;@fr<br>&lt;http://people/fred&gt; &lt;http://people/favoriteColor&gt; &quot;Rouge&quot;<br>&lt;http://people/eric&gt; &lt;http://people/favoriteColor&gt; &quot;Rouge&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;<br>&lt;http://people/dave&gt; &lt;http://people/favoriteColor&gt; &quot;rouge&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; </pre>
<p>This query matched all triples containing the string &quot;rouge&quot; regardless of datatype or language tag. Remember that the SPARQL &quot;filter&quot; queries are powerful, but they are also the slowest queries. SPARQL direct queries and getStatements() queries are faster. </p>
<h3>Matching Booleans</h3>
<p>In this section we'll assert and then search for Boolean values.</p>
<h3>Asserting Boolean Values</h3>
<p>The Python language includes predefined True and False symbols for use in your decision-making logic. These Boolean constants are fine for programming, but they are not appropriate for asserting Boolean values into triples. They do not result in legal RDF Boolean values, and this creates subsequent matching issues.</p>
<p>We'll be adding a new attribute to the person resources in our example. Are they, or are they not, seniors?</p>
<pre class="input">    senior = conn.createURI(namespace=exns, localname=&quot;seniorp&quot;)    </pre>
<p>The correct way to create Boolean values for use in triples is to create literal values of type Boolean:</p>
<pre class="input">    trueValue = conn.createLiteral(&quot;true&quot;, datatype=XMLSchema.BOOLEAN)<br>    falseValue = conn.createLiteral(&quot;false&quot;, datatype=XMLSchema.BOOLEAN)</pre>
<p>Note that &quot;true&quot; and &quot;false&quot; must be lower case. </p>
<p>We'll only need two triples:</p>
<pre class="input">    conn.addTriple(alice, senior, trueValue)<br>    conn.addTriple(bob, senior, falseValue)</pre>
<p>When we retrieve the triples (using getStatements()) we see:</p>
<pre class="output">(&lt;http://people/bob&gt;, &lt;http://people/seniorp&gt;, &quot;false&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;)<br>(&lt;http://people/alice&gt;, &lt;http://people/seniorp&gt;, &quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;) </pre>
<p>These are RDF-legal Boolean values that work with the AllegroGraph query engine. Note that &quot;true&quot; and &quot;false&quot; are lower case.</p>
<p>As an object lesson, this getStatements() query uses the Python &quot;True&quot; Boolean, which does not match the values in the RDF store:</p>
<pre class="input">conn.getStatements(None, senior, True)     # no matches</pre>
<p><strong>&quot;Match 'true'.&quot;</strong> There are three correct ways to perform a Boolean search. One is to use the varible trueValue (defined above) to pass a Boolean literal value to getStatements(). SPARQL queries will recognize <strong>true</strong> and <strong>false</strong>, and of course the fully-typed <strong>&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;</strong> format is also respected by SPARQL:</p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, senior, trueValue)</td>
    <td><p>&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;<br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p true}</td>
    <td><p>&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;</p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;</td>
    <td>&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;</td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = true)}</td>
    <td>&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;</td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;}</td>
    <td>&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;</td>
  </tr>
</table>
<p>All of these queries correctly match Boolean values. </p>
<h3>Dates, Times and Datetimes </h3>
<p>In this final section of example5(), we'll assert and retrieve dates, times and datetimes. </p>
<p>In this context, you might be surprised by the way that AllegroGraph handles time zone data. If you assert (or search for) a timestamp that includes a time-zone offset, AllegroGraph will &quot;normalize&quot; the expression to Greenwich (zulu) time before proceeding. This normalization greatly speeds up searching and happens transparently to you, but you'll notice that the matched values are all zulu times. </p>
<h3>Asserting Date, Time and Datetime Values</h3>
<p>We're going to add birthdates to our personnel records. We'll need a birthdate predicate:</p>
<pre class="input">    birthdate = conn.createURI(namespace=exns, localname=&quot;birthdate&quot;)  </pre>
<p>We'll also need four types of literal values: a date, a time, a datetime, and a datetime with a time-zone offset.</p>
<pre class="input">    date = conn.createLiteral('1984-12-06', datatype=XMLSchema.DATE)     <br>    datetime = conn.createLiteral('1984-12-06T09:00:00', datatype=XMLSchema.DATETIME) <br>    time = conn.createLiteral('09:00:00Z', datatype=XMLSchema.TIME) <br>    datetimeOffset = conn.createLiteral('1984-12-06T09:00:00+01:00', datatype=XMLSchema.DATETIME)</pre>
<p>It is interesting to notice that these literal values print out exactly as we defined them. </p>
<pre class="output">Printing out Literals for date, datetime, time, and datetime with Zulu offset.<br>&quot;1984-12-06&quot;^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;<br>&quot;1984-12-06T09:00:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;<br>&quot;09:00:00Z&quot;^^&lt;http://www.w3.org/2001/XMLSchema#time&gt;<br>&quot;1984-12-06T09:00:00+01:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;</pre>
<p>Now we'll add them to the triple store:</p>
<pre class="input">    conn.addTriples([(alice, birthdate, date),<br>                     (bob, birthdate, datetime),<br>                     (carol, birthdate, time),<br>                     (dave, birthdate, datetimeOffset)])</pre>
<p>And then retrieve them using getStatements():</p>
<pre class="output">Showing all birthday triples using getStatements(). Should be four.<br>(&lt;http://people/alice&gt;, &lt;http://people/birthdate&gt;, &quot;1984-12-06&quot;^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;)<br>(&lt;http://people/bob&gt;, &lt;http://people/birthdate&gt;, &quot;1984-12-06T09:00:00Z&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;)<br>(&lt;http://people/carol&gt;, &lt;http://people/birthdate&gt;, &quot;09:00:00Z&quot;^^&lt;http://www.w3.org/2001/XMLSchema#time&gt;)<br>(&lt;http://people/dave&gt;, &lt;http://people/birthdate&gt;, &quot;1984-12-06T08:00:00Z&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;)</pre>
<p>If you look sharply, you'll notice that the zulu offset has been normalized:</p>
<pre>Was:<span class="output">&quot;1984-12-06T09:00:00+01:00&quot;</span>
Now:<span class="output">&quot;1984-12-06T08:00:00Z&quot;</span></pre>
<p>Note that the one-hour zulu offset has been applied to the timestamp. &quot;9:00&quot; turned into &quot;8:00.&quot; </p>
<h3>Matching Date, Time, and Datetime Literals</h3>
<p><strong>&quot;Match date.&quot;</strong> What happens if we search for the date literal we defined? We'll use the &quot;date&quot; variable with getStatements(), but just type the expected value into the SPARQL queries. </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, date)</td>
    <td><p>&quot;1984-12-06&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;<br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p '1984-12-06'^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;</td>
    <td><p>&quot;1984-12-06&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;</p></td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o =<br> 
    '1984-12-06'<br>
    ^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;)}</td>
    <td>&quot;1984-12-06&quot;<br>
    ^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;</td>
  </tr>
</table>
<p>All three queries match narrowly, meaning the exact date and datatype we asked for is returned. </p>
<p><strong>&quot;Match datetime.&quot;</strong> What happens if we search for the datetime literal? We'll use the &quot;datetime&quot; variable with getStatements(), but just type the expected value into the SPARQL queries. </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, datetime)</td>
    <td><p>&quot;1984-12-06T09:00:00Z&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;<br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p '1984-12-06T09:00:00Z'<br>
    ^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .}</td>
    <td><p>&quot;1984-12-06T09:00:00Z&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;</p></td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = '1984-12-06T09:00:00Z'^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;)}</td>
    <td>&quot;1984-12-06T09:00:00Z&quot;<br>
    ^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;</td>
  </tr>
</table>
<p>The matches are specific for the exact date, time and type. </p>
<p><strong>&quot;Match time.&quot;</strong> What happens if we search for the time literal? We'll use the &quot;time&quot; variable with getStatements(), but just type the expected value into the SPARQL queries. </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, time)</td>
    <td><p>&quot;09:00:00Z&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#time&gt;<br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;09:00:00Z&quot;<br>
    ^^&lt;http://www.w3.org/2001/XMLSchema#time&gt; .}</td>
    <td><p>&quot;09:00:00Z&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#time&gt;</p></td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;09:00:00Z&quot;^^&lt;http://www.w3.org/2001/XMLSchema#time&gt;)}</td>
    <td>&quot;09:00:00Z&quot;<br>
    ^^&lt;http://www.w3.org/2001/XMLSchema#time&gt;</td>
  </tr>
</table>
<p>The matches are specific for the exact time and type. </p>
<p><strong>&quot;Match datetime with offset.&quot;</strong> What happens if we search for a datetime with zulu offset? </p>
<table width="1038" border="1">
  <tr>
    <td width="140"><strong>Query Type </strong></td>
    <td width="368"><strong>Query</strong></td>
    <td width="508"><strong>Matches which types? </strong></td>
  </tr>
  <tr>
    <td><strong>getStatements()</strong></td>
    <td>conn.getStatements(None, age, datetimeOffset)</td>
    <td><p>&quot;1984-12-06T08:00:00Z&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;<br>
    </p></td>
  </tr>
  <tr>
    <td><strong>SPARQL direct match </strong></td>
    <td>SELECT ?s ?p WHERE {?s ?p &quot;1984-12-06T09:00:00+01:00&quot;<br>
^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .}</td>
    <td><p>&quot;1984-12-06T08:00:00Z&quot;<br>
      ^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;</p></td>
  </tr>
  <tr>
    <td><strong>SPARQL filter match </strong></td>
    <td><p>SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot;1984-12-06T09:00:00+01:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;)}</p>    </td>
    <td>&quot;1984-12-06T08:00:00Z&quot;<br>
    ^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;</td>
  </tr>
</table>
<p>Note that we searched for &quot;1984-12-06T09:00:00+01:00&quot; but found &quot;1984-12-06T08:00:00Z&quot;. It is the same moment in time. </p>
<h2 id="Importing Triples">Importing Triples (example6() and example7()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
The Python Sesame API client can load triples in either RDF/XML format or  NTriples format.  The example below calls the connection object's <strong>add()</strong> method to load 
an NTriples file, and <strong>addFile()</strong> to load  an RDF/XML file. Both methods work, but the best practice is to use addFile(). </p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td width="928"><strong>Note:</strong> If you get a &quot;file not found&quot; error while running this example, it means that Python is looking in the wrong directory for the data files to load. The usual explanation is that you have moved the tutorial_examples_40.py file to an unexpected directory. You can clear the issue by putting the data files in the same directory as tutorial_examples_40.py, or by setting the Python current working directory to the location of the data files using os.setcwd(). </td>
  </tr>
</table>
<p>The RDF/XML file contains a short list of v-cards (virtual business cards), like this one:</p>
<pre>  &lt;rdf:Description rdf:about=&quot;http://somewhere/JohnSmith/&quot;&gt;<br>    &lt;vCard:FN&gt;John Smith&lt;/vCard:FN&gt;<br>    &lt;vCard:N rdf:parseType=&quot;Resource&quot;&gt;<br>	    &lt;vCard:Family&gt;Smith&lt;/vCard:Family&gt;<br>	    &lt;vCard:Given&gt;John&lt;/vCard:Given&gt;<br>    &lt;/vCard:N&gt;<br>  &lt;/rdf:Description&gt; </pre>
<p>The NTriples file contains a graph of resources describing the Kennedy family, the places where they were each born, their colleges, and their professions. A typical entry from that file looks like this:</p>
<pre>&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#first-name&gt; &quot;Joseph&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#middle-initial&gt; &quot;Patrick&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#last-name&gt; &quot;Kennedy&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#suffix&gt; &quot;none&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#alma-mater&gt; &lt;http://www.franz.com/simple#Harvard&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#birth-year&gt; &quot;1888&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#death-year&gt; &quot;1969&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#sex&gt; &lt;http://www.franz.com/simple#male&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#spouse&gt; &lt;http://www.franz.com/simple#person2&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#has-child&gt; &lt;http://www.franz.com/simple#person3&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#profession&gt; &lt;http://www.franz.com/simple#banker&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#birth-place&gt; &lt;http://www.franz.com/simple#place5&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.franz.com/simple#person&gt; . </pre>

<p>Note that AllegroGraph can segregate triples into contexts (subgraphs) by treating them as quads, but the NTriples and RDF/XML formats can not include context information. They deal with triples only, so there is no place to store a fourth field in those formats. In the case of the add() call, we have omitted the context
  argument so the triples are loaded the default background graph (sometimes called the &quot;null context<em>.</em>&quot;) The
  addFile() call includes an explicit context setting, so the fourth argument of
  each vcard triple will be the context named "/tutorial/vc_db_1_rdf".
  The connection size() method takes an optional context argument.  With no
  argument, it returns the total number of triples in the repository.  Below, it returns the number
  '16' for the 'context' context argument, and the number '28' for the null context
  (None) argument. </p>
<p>The example6() function of tutorial_examples_40.py creates a <a href="#Transaction Control">dedicated session</a> connection to AllegroGraph, using methods you have seen before, plus the Connection object's <strong>openSession()</strong> method: </p>
<pre class="input">def example6(close=True):<br>    print &quot;Starting example6().&quot;<br>    server = AllegroGraphServer(AG_HOST, AG_PORT, AG_USER, AG_PASSWORD)<br>    catalog = server.openCatalog(AG_CATALOG)  <br>    myRepository = catalog.getRepository(AG_REPOSITORY, Repository.RENEW)<br>    myRepository.initialize()<br>    conn = myRepository.getConnection()<br>    conn.clear()<br>    conn.openSession()</pre>
<p>The dedicated session is not immediately pertinent to the examples in this section, but will become important in later examples that reuse this connection to demonstrate <a href="#Prolog Rule Queries">Prolog Rules</a> and <a href="#Social Network Analysis">Social Network Analysis</a>. </p>
<p>The variables path1 and path2 are bound to the RDF/XML and NTriples files, respectively. </p>
<pre class="input">    path1 = &quot;./python-vcards.rdf&quot;    <br>    path2 = &quot;./python-kennedy.ntriples&quot;                </pre>
<p>The NTriples about the vcards will be added to a specific context, so naturally we need a URI to identify that context. </p>
<pre class="input">    context = conn.createURI(&quot;http://example.org#vcards&quot;)</pre>
<p>In the next step we use addFile() to load the vcard triples into the #vcards context: </p>
<pre class="input">    conn.addFile(path1, None, format=RDFFormat.RDFXML, context=context)</pre>
<p>Then we use add() to load the Kennedy family tree into the null context: </p>
<pre class="input">    conn.add(path2, base=None, format=RDFFormat.NTRIPLES, contexts=None)</pre>
<p>Now we'll ask AllegroGraph to report on how many triples it sees in the null context and in the #vcards context: </p>
<pre class="input">    print &quot;After loading, repository contains %i vcard triples in context '%s'\n    
           and   %i kennedy triples in context '%s'.&quot; % <br>           (conn.size(context), context, conn.size('null'), 'null')<br>    return conn</pre>
<p>The output of this report was:</p>
<pre class="output">After loading, repository contains 16 vcard triples in context 'http://example.org#vcards'<br>    and   1214 kennedy triples in context 'null'. </pre>
<p>The SPARQL query below is found in example7() of tutorial_examples_40.py. It borrows the same triples we loaded in example6(), above, and runs two unconstrained retrievals. The first uses getStatement, and prints out the subject URI and context of each triple. </p>
<pre class="input">def example7():    <br>    conn = example6()<br>    print &quot;Match all and print subjects and contexts&quot;<br>    result = conn.getStatements(None, None, None, None, limit=25)<br>    for row in result: print row.getSubject(), row.getContext()</pre>
<p>This loop prints out a mix of triples from the null context and from the #vcards context. We set a limit of 25 triples because the Kennedy dataset contains over a thousand triples. </p>
<p>The following loop, however, does not produce the same results. This is a SPARQL query that should match all available triples, printing out the subject and context of each triple. We limited this query by using the DISTINCT keyword. Otherwise there would be many duplicate results. </p>
<pre class="input">    print &quot;\nSame thing with SPARQL query (can't retrieve triples in the null context)&quot;<br>    queryString = &quot;SELECT DISTINCT ?s ?c WHERE {graph ?c {?s ?p ?o .} }&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    result = tupleQuery.evaluate();<br>    for i, bindingSet in enumerate(result):<br>        print bindingSet[0], bindingSet[1]<br>    conn.close()</pre>
<p>In this case, the loop prints out only v-card results.  The SPARQL query is not able to access the null context when a non-null context is also present. </p>
<h2 id="Exporting Triples">Exporting Triples (example8() and example9()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The next examples show how to write triples out to a file in either NTriples format or RDF/XML format. The output of either format may be optionally redirected to standard output (the Python command window) for inspection.</p>
<p>Example example8() begins by obtaining a connection object from example6(). This means the repository contains v-card triples in the <strong>#vcards</strong> context, and Kennedy family tree triples in the<strong> null </strong>context. </p>
<pre class="input">def example8():<br>    conn = example6()</pre>
<p>In this example, we'll export the triples in the #vcards context. </p>
<pre class="input">    context = conn.createURI(&quot;http://example.org#vcards&quot;)</pre>
<p>To write triples in
NTriples format, call NTriplesWriter(). You have to tell it the path and file name of the exported file. If the output file argument is 'None', the writers write to standard
output. You can uncomment that line if you'd like to see it work. This code exports the vcards triples in ntriples format:</p>
<pre class="input">    outputFile = &quot;/tmp/temp.nt&quot;<br>    #outputFile = None<br>    if outputFile == None:<br>        print &quot;Writing RDF to Standard Out instead of to a file&quot;<br>    ntriplesWriter = NTriplesWriter(outputFile)<br>    conn.export(ntriplesWriter, context);</pre>
<p>To write triples in RDF/XML format, call RDFXMLWriter(). This code exports the Kennedy triples in RDF/XML format.</p>
<pre class="input">    outputFile2 = &quot;/tmp/temp.rdf&quot;<br>    #outputFile2 = None<br>    if outputFile2 == None:<br>        print &quot;Writing NTriples to Standard Out instead of to a file&quot;<br>    rdfxmlfWriter = RDFXMLWriter(outputFile2)    <br>    conn.export(rdfxmlfWriter, 'null')</pre>
<p>
The <strong>export()</strong> method writes
  out all triples in one or more contexts.  This provides a convenient means for making
  local backups of sections of your RDF store.  The 'null' argument targets the triples of the default graph. If two or more contexts are specified,
  then triples from all of those contexts will be written to<em> the same file</em>.  Since the
triples are "mixed together" in the file, the context information is not recoverable. If the context argument is omitted, all triples in the store are written out, and again all context information is lost. </p>
<p>Finally, if the objective is to write out a filtered set of triples,
  the <strong>exportStatements()</strong> method can be used.  The example below (from<strong> example9()</strong>) writes
  out all <strong>familyName</strong> triples from the vcards context to standard output. </p>
<pre class="input">
    familyName = conn.createURI("http://www.w3.org/2001/vcard-rdf/3.0#FN")
    conn.exportStatements(None, familyName, None, False, RDFXMLWriter(None), context)
</pre>

<h2 id="Datasets and Contexts">Searching Multiple Graphs   (example10()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
 We have already seen contexts (subgraphs) at work when loading and saving files. In example10() we provide more realistic examples of contexts, and we explore the FROM, FROM DEFAULT, and FROM NAMED clauses of a SPARQL query to see how they interact with multiple subgraphs in the triple store. Finally, we will introduce the dataset object. A dataset is a list of contexts that should all be searched simultaneously. It is an object for use with SPARQL queries.
</p>
<p>To set up the example, we create six statements, and add two
  of each to three different contexts: context1, context2, and the null context. The process of setting up the six statements follows the same pattern as we used in the previous examples: </p>
<pre class="input">    ## Create URIs for resources, predicates and classes.<br>    exns = &quot;http://example.org/people/&quot;<br>    alice = conn.createURI(namespace=exns, localname=&quot;alice&quot;)<br>    bob = conn.createURI(namespace=exns, localname=&quot;bob&quot;)<br>    ted = conn.createURI(namespace=exns, localname=&quot;ted&quot;)<br>    person = conn.createURI(namespace=exns, localname=&quot;Person&quot;)<br>    name = conn.createURI(namespace=exns, localname=&quot;name&quot;)  <br>    ## Create literal name values.  <br>    alicesName = conn.createLiteral(&quot;Alice&quot;)    <br>    bobsName = conn.createLiteral(&quot;Bob&quot;)<br>    tedsName = conn.createLiteral(&quot;Ted&quot;)    <br>    ## Create URIs to identify the named contexts. <br>    context1 = conn.createURI(namespace=exns, localname=&quot;context1&quot;)      <br>    context2 = conn.createURI(namespace=exns, localname=&quot;context2&quot;)  </pre>

<p>The next step is to assert two triples into each of three contexts: </p>



<pre class="input">    ## Assemble new statements and add them to the contexts.        <br>    conn.add(alice, RDF.TYPE, person, context1)<br>    conn.add(alice, name, alicesName, context1)<br>    conn.add(bob, RDF.TYPE, person, context2)<br>    conn.add(bob, name, bobsName, context2)<br>    conn.add(ted, RDF.TYPE, person)   // Added to null context<br>    conn.add(ted, name, tedsName)     // Added to null context</pre>
<p> Note that the final two statements (about Ted) were added to the null context (the unnamed default graph). </p>
<h3>GetStatements</h3>
<p> The first test uses <strong>getStatements()</strong> to return all triples in all contexts (context1, context2, and null). This is default search behavior, so there is no need to specify the contexts in the<strong> conn.getStatements()</strong> method. Note that <strong>conn.size()</strong> also reports on all contexts by default. </p>
<pre class="input">    statements = <strong>conn.getStatements(None, None, None)</strong><br>    print &quot;All triples in all contexts: %s&quot; % <strong>(conn.size())</strong>   <br>    for s in statements:<br>        print s</pre>
<p>The output of this loop is shown below. The context URIs are in the fourth position. Triples from the null context have no context value. </p>
<pre class="output">All triples in all contexts: 6<br>(&lt;http://example.org/people/alice&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;, &lt;http://example.org/people/context1&gt;)<br>(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/name&gt;, &quot;Alice&quot;, &lt;http://example.org/people/context1&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;, &lt;http://example.org/people/context2&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/name&gt;, &quot;Bob&quot;, &lt;http://example.org/people/context2&gt;)<br>(&lt;http://example.org/people/ted&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;)<br>(&lt;http://example.org/people/ted&gt;, &lt;http://example.org/people/name&gt;, &quot;Ted&quot;)</pre>
<!--
<p>Our second experiment explicitly asks for the triples in the null context:</p>
<pre class="input">    statements = conn.getStatements(None, None, None, ['null'])<br>    print &quot;All triples in null context: %s&quot; % (conn.size(['null']))   <br>    for s in statements:<br>        print s</pre>
<p>Note that we identified the null context as ['null'], which is a tuple containing the value 'null'. That tuple can contain as many context URIs as necessary, as will will see in the next example. In this instance, getStatements() found two triples:</p>
<pre class="output">All triples in null context: 2<br>(&lt;http://example.org/people/ted&gt;, &lt;http://example.org/people/name&gt;, &quot;Ted&quot;)<br>(&lt;http://example.org/people/ted&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;) </pre>
-->
<p>The next match explicitly lists 'context1' and 'context2' as the only contexts to participate in the match. It returns four statements. 


 The conn.size() method can also address individual contexts.</p>
<pre class="input">    statements = conn.getStatements(None, None, None, [context1, context2])<br>    print &quot;Triples in contexts 1 or 2: %s&quot; % (conn.size([context1, context2]))<br>    for s in statements:<br>        print s</pre>
<p>The output of this loop shows that the triples in the null context have been excluded. </p>
<pre class="output">Triples in contexts 1 or 2: 4<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/name&gt;, &quot;Bob&quot;, &lt;http://example.org/people/context2&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;, &lt;http://example.org/people/context2&gt;)<br>(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/name&gt;, &quot;Alice&quot;, &lt;http://example.org/people/context1&gt;)<br>(&lt;http://example.org/people/alice&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;, &lt;http://example.org/people/context1&gt;)</pre>
<p>This time we use getStatements() to search explicitly for triples in the null context and in context 2.</p>
<pre class="input">    statements = conn.getStatements(None, None, None, ['null', context2])<br>    print &quot;Triples in contexts null or 2: %s&quot; % (conn.size(['null', context2]))<br>    for s in statements:<br>        print s</pre>
<p>The output of this loop is:</p>
<pre class="output">Triples in contexts null or 2: 4<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/name&gt;, &quot;Bob&quot;, &lt;http://example.org/people/context2&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;, &lt;http://example.org/people/context2&gt;)<br>(&lt;http://example.org/people/ted&gt;, &lt;http://example.org/people/name&gt;, &quot;Ted&quot;)<br>(&lt;http://example.org/people/ted&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;)</pre>
<p> The lesson is that getStatements() can freely mix triples from the null context and named contexts. It is all you need as long as the query is a very simple one. </p>
<h3>SPARQL using FROM, FROM DEFAULT, and FROM NAMED </h3>
<p>In many of our examples we have used a simple SPARQL query to retrieve triples from AllegroGraph's default graph. This has been very convenient but it is also misleading. As soon as we tell SPARQL to search a <em>specific</em> graph, we lose the ability to search AllegroGraph's default graph! Triples from the null graph vanish from the search results. Why is that? </p>
<ul>
  <li style="margin-bottom: 15px ">It is important to understand that AllegroGraph and SPARQL use the phrase &quot;default graph&quot; to identify two very different things. AllegroGraph's default graph, or null context, is simply the set of all triples that have &quot;null&quot; in the fourth field of the &quot;triple.&quot; The &quot;default graph&quot; is an <em>unnamed subgraph</em> of the AllegroGraph triple store. </li>
  <li>SPARQL uses &quot;default graph&quot; to describe something that is very different. In SPARQL, the &quot;default graph&quot; is a temporary pool of triples imported from one or more &quot;named&quot; graphs. SPARQL's &quot;default graph&quot; is constructed and discarded in the service of a single query. </li>
</ul>
<p>Standard SPARQL was designed for <em>named graphs only</em>, and has no syntax to indentify a truly unnamed graph. AllegroGraph's SPARQL, however, has been extended to allow the unnamed graph to participate in multi-graph queries. </p>
<p>We can use AllegroGraph's SPARQL to search specific subgraphs in three ways. We can create a temporary &quot;default graph&quot; using the FROM operator; we can put AllegroGraph's unnamed graph into SPARQL's default graph using FROM DEFAULT; or we can target specific named graphs using the FROM NAMED operator. </p>
<ul>
  <li style="margin-bottom: 15px "><strong>FROM</strong> takes one (or more) subgraphs identified by their URIs and temporarily turns them into a single default graph.&nbsp; We match triples in this graph using simple (non-GRAPH) patterns. </li>
  <li style="margin-bottom: 15px "><strong>FROM DEFAULT</strong> takes AllegroGraph's null graph and temporarily makes it part of SPARQL's default graph. Again, we use simple patterns to match this graph. </li>
  <li><strong>FROM NAMED</strong> takes one (or more) named graphs, and declares them to be named graphs in the query.&nbsp; Named graphs must be addressed using explicit GRAPH patterns. </li>
</ul>
<p>We can also combine these operators in a single query, to search the SPARQL default graph and one or more named graphs at the same time. 
<p>The first example is a SPARQL query that used FROM DEFAULT to place AllegroGraph's unnamed graph into SPARQL's default graph.&nbsp; 
<pre class="input">SELECT ?s ?p ?o FROM DEFAULT <br>WHERE {?s ?p ?o . }</pre>
<p>This query finds triples from the unnamed graph only (which are triples about Ted).&nbsp; Note the simple query pattern. 
<pre class="output">['&lt;http://example.org/people/ted&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Ted&quot;']
</pre>
<p>Here's an example of a query that uses FROM. It instructs SPARQL to regard context1 as the default graph for the purposes of this query. 
<pre class="input">SELECT ?s ?p ?o 
FROM &lt;http://example.org/people/context1&gt; 
WHERE {?s ?p ?o . }</pre>
<p>SPARQL uses the simple pattern {?s ?p ?o . } to match triples in context1, which is the temporary default graph:</p>
<pre class="output">['&lt;http://example.org/people/alice&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Alice&quot;']</pre>
<p>Notice that these query results do not have the fourth value we have come to expect.&nbsp; That was stripped off when context1 became the (temporary) default context.&nbsp; </p>
<p>The next example changes FROM to FROM NAMED in the same query:</p>
<pre class="input">SELECT ?s ?p ?o 
FROM NAMED &lt;http://example.org/people/context1&gt; 
WHERE {?s ?p ?o . }</pre>
<p>This time there are no matches! The pattern {?s ?p ?o . } only matches the SPARQL default graph. We declared context1 to be a &quot;named&quot; graph, so it is no longer the default graph. To match triples in named graphs, SPARQL requires a GRAPH pattern: </p>
<pre class="input">SELECT ?s ?p ?o ?g 
FROM NAMED &lt;http://example.org/people/context1&gt; 
WHERE {GRAPH ?g {?s ?p ?o . }}&quot;;</pre>
<p>When we combine GRAPH with FROM NAMED, we get the expected matches: </p>
<pre class="output">['&lt;http://example.org/people/alice&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;', '&lt;http://example.org/people/context1&gt;']<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Alice&quot;', '&lt;http://example.org/people/context1&gt;']</pre>
<p>What about a combination query? The graph commands can be mixed in a single query.</p>
<pre class="input">SELECT ?s ?p ?o ?g <br>FROM DEFAULT<br>FROM &lt;http://example.org/people/context1&gt;<br>FROM NAMED &lt;http://example.org/people/context2&gt; <br>WHERE {{GRAPH ?g {?s ?p ?o . }} UNION {?s ?p ?o .}}</pre>
<p>This query puts AllegroGraph's unnamed graph and the context1 graph into SPARQL's default graph, where the triples can be found by using a simple {?s ?p ?o . } query.&nbsp; Then it identifies context2 as a named graph, which can be searched using a GRAPH pattern.&nbsp; In the final line, we used a UNION operator to combine the matches of the simple and GRAPH patterns. </p>
<p>This query should find all six triples, and here they are: </p>
<pre class="output">['&lt;http://example.org/people/bob&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;', '&lt;http://example.org/people/context2&gt;']<br>['&lt;http://example.org/people/bob&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Bob&quot;', '&lt;http://example.org/people/context2&gt;']<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Alice&quot;']<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Ted&quot;'] </pre>
<h3>SPARQL with Dataset Object</h3>
<p>Next, we switch to SPARQL queries where the subgraphs are constrained by Sesame dataset objects. First we'll run the wide-open SPARQL query to see what it finds. In the next two SPARQL examples, we will control the scope of the search by using datasets. A dataset contains lists of contexts to search, and is applied to the tupleQuery object to control the scope of the search. </p>
<p>Here's the wide-open search, which contains no information about which graph we want to search:</p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o WHERE {?s ?p ?o . } <br>    &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    result = tupleQuery.evaluate(); <br>    print &quot;No dataset restrictions.&quot;<br>    for bindingSet in result:<br>        print bindingSet.getRow()</pre>
<p>In this case the query returns triples from AllegroGraph's default graph <em>and </em>from both named graphs. This accommodates the person who just wants to &quot;search everything.&quot; </p>
<pre class="output">No dataset restrictions.<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Alice&quot;']<br>['&lt;http://example.org/people/bob&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/bob&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Bob&quot;']<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Ted&quot;']</pre>
<p>A dataset object is a Sesame construct that contains two lists of named graphs. There is one list of graphs that will become the SPARQL default graph, just like using FROM in the query. There is a second list of graphs that will be &quot;named&quot; graphs in the query, just like using FROM NAMED. To use the dataset, we put the graph URIs into the dataset object, and then add the dataset to the tupleQuery object. When we evaluate the tupleQuery, the results will be confined to the graphs listed in the dataset. </p>
<p>The next example shows how to use an AllegroGraph <strong>dataset</strong> object in an exceptional way, to restrict the SPARQL query to the triples in AllegroGraph's default graph. The dataset.addDefaultGarph() method accepts &quot;null&quot; as the name of AllegroGraph's default graph. This lets us direct a SPARQL query at AllegoGraph's default graph. </p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o WHERE {?s ?p ?o . } <br>    &quot;&quot;&quot;<br>    ds = Dataset()<br>    <strong>ds.addDefaultGraph('null')</strong><br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    tupleQuery.setDataset(ds)   <br>    result = tupleQuery.evaluate(); <br>    print &quot;SPARQL query over the null context.&quot;<br>    for bindingSet in result:<br>        print bindingSet.getRow()</pre>
<p>The output of this loop is the two triples that are in the default graph:</p>
<!-- TODO Java was returning six triples, should be two. -->
<pre class="output">SPARQL query over the null context.<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Ted&quot;']</pre>
<p>In the next example  we'll add a graph to the dataset using the<strong> addNamedGraph() </strong>method. This time the wide-open query is restricted to only those statements in context1, which will be treated as a &quot;named graph&quot; in the query:</p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o WHERE {?s ?p ?o . } <br>    &quot;&quot;&quot;<br>    ds = Dataset()<br>    <strong>ds.addNamedGraph(context1)</strong><br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    tupleQuery.setDataset(ds)<br>    result = tupleQuery.evaluate(); <br>    print &quot;SPARQL query over context1, no GRAPH pattern.&quot;<br>    for bindingSet in result:<br>        print bindingSet.getRow()</pre>
<p>The output of this query is somewhat unexpected. The query returns no results! </p>
<pre class="output">SPARQL query over context1, no GRAPH pattern.</pre>
<p>Why did this happen? Once we explicitly identify a subgraph as a &quot;named graph&quot; in the query, SPARQL insists that we use a GRAPH pattern. The following example uses a dataset to target context1, and adds a GRAPH element to the query. This small change lets us focus on one subgraph only. </p>
<pre class="input">    queryString = &quot;&quot;&quot;<br><strong>    SELECT ?s ?p ?o ?c<br>    WHERE { GRAPH ?c {?s ?p ?o . } } </strong><br>    &quot;&quot;&quot;<br>    ds = Dataset()<br>    ds.addNamedGraph(context1)<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    tupleQuery.setDataset(ds)<br>    result = tupleQuery.evaluate(); <br>    print &quot;SPARQL query over context1, with GRAPH pattern.&quot;<br>    for bindingSet in result:<br>        print bindingSet.getRow()</pre>
<p>The output of this loop contains two triples, as expected. These are the triples from context1.</p>
<pre class="output">SPARQL query over context1, with GRAPH pattern.<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;', '&lt;http://example.org/people/context1&gt;']<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Alice&quot;', '&lt;http://example.org/people/context1&gt;']</pre>
<p>One naturally wonders what the SPARQL GRAPH query would find if we got out of its way and ran it without any dataset restrictions. Here it is:</p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o ?c<br>    WHERE { GRAPH ?c {?s ?p ?o . } } <br>    &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    result = tupleQuery.evaluate(); <br>    print &quot;SPARQL query with GRAPH pattern, no context constraints.&quot;<br>    for bindingSet in result:<br>        print bindingSet.getRow()</pre>
<p>The output of this loop contains four triples, two from each of the named subgraphs in the store (context1 and context2). The query was not able to find the triples that were in the AllegroGraph default graph. </p>
<pre class="output">SPARQL query with GRAPH pattern, no context constraints.<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;', '&lt;http://example.org/people/context1&gt;']<br>['&lt;http://example.org/people/alice&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Alice&quot;', '&lt;http://example.org/people/context1&gt;']<br>['&lt;http://example.org/people/bob&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;', '&lt;http://example.org/people/context2&gt;']<br>['&lt;http://example.org/people/bob&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Bob&quot;', '&lt;http://example.org/people/context2&gt;']</pre>
<h2 id="Namespaces">Namespaces (example11()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
A <i>namespace</i> is that portion of a URI that preceeds the last '#',
'/', or ':' character, inclusive.  The remainder of a URI is called the
<i>localname</i>.  For example, with respect to the URI "http://example.org/people/alice",
the namespace is "http://example.org/people/" and the localname is "alice".
When writing SPARQL queries, it is convenient to define prefixes or nicknames
for the namespaces, so that abbreviated URIs can be specified.  For example,
if we define "ex" to be a nickname for "http://example.org/people/", then the
string "ex:alice" is a recognized abbreviation for "http://example.org/people/alice".
This abbreviation is called a <i>qname</i>.
</p>
<p>
In the SPARQL query in the example below, we see two qnames, "rdf:type" and
"ex:alice".  Ordinarily, we would expect to see "PREFIX" declarations in
SPARQL that define namespaces for the "rdf" and "ex" nicknames.  However,
the Connection and Query machinery can do that job for you.  The
mapping of prefixes to namespaces includes the built-in prefixes RDF, RDFS, XSD, and OWL.
Hence, we can write "rdf:type" in a SPARQL query, and the system already knows
its meaning.  In the case of the 'ex' prefix, we need to instruct it.  The
setNamespace() method of the connection object registers a new namespace.  In the example
below, we first register the 'ex' prefix, and then submit the SPARQL query.
It is legal, although not recommended, to redefine the built-in prefixes RDF, etc..
</p>
<p>The example example11() begins by borrowing a connection object from example1(). </p>
<pre class="input">def example11():<br>    conn = example1()</pre>
<p>We need a namespace string (bound to the variable <strong>exns</strong>) to use when generating the <strong>alice</strong> and <strong>person</strong> URIs. </p>
<pre class="input">
    exns = &quot;http://example.org/people/&quot;<br>    alice = conn.createURI(namespace=exns, localname=&quot;alice&quot;)<br>    person = conn.createURI(namespace=exns, localname=&quot;Person&quot;)</pre>
<p>Now we can assert Alice's RDF:TYPE triple. </p>
<pre class="input">
    conn.add(alice, RDF.TYPE, person)</pre>
<p>Now we register the exns namespace with the connection object, so we can use it in a SPARQL query. The query looks for triples that have &quot;rdf:type&quot; in the predicate position, and &quot;ex:Person&quot; in the object position. </p>
<pre class="input">
    conn.setNamespace('ex', exns)<br>    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o <br>    WHERE { ?s ?p ?o . FILTER ((?p = rdf:type) &amp;&amp; (?o = ex:Person) ) }<br>    &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    result = tupleQuery.evaluate();  <br>    print    <br>    for bindingSet in result:<br>        print bindingSet[0], bindingSet[1], bindingSet[2]</pre>
<p>The output shows the single triple with its fully-expanded URIs.  This demonstrates that the qnames in the SPARQL query successfully matched the fully-expanded URIs in the triple. </p>
<pre class="output">http://example.org/people/alice http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://example.org/people/Person</pre>
<p>It is worthwhile to briefly discuss performance here.  In the current
  AllegroGraph system, queries run more efficiently if constants appear inside
  of the "where" portion of a query, rather than in the "filter" portion.  For
  example, the SPARQL query below will evaluate more efficiently than the one
  in the above example.  However, in this case, you have lost the ability to
  output the constants "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" and
"http://example.org/people/alice".  Occasionally you may find it useful to
  output constants in the output of a 'select' clause; in general though,
  the above code snippet illustrates a query syntax that is discouraged. </p>
<pre class="input">
SELECT ?s  
WHERE { ?s rdf:type ex:person } 
</pre>

<h2 id="Free Text Search">Free Text Search (example12()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
It is common for users to build RDF applications that combine
some form of "keyword search" with their queries. For example, a user
might want to retrieve all triples for which the string "Alice" appears
as a word within the third (object) argument to the triple.  AllegroGraph
provides a capability for including free text matching within a SPARQL
query, and also by using the <strong>evalFreeTextSearch()</strong> method of the connection object.  It requires, however, that you create and configure indexes appropriate to the searches you want to pursue. </p>
<p> Example12() begins by borrowing the connection object from example1(). Then it creates a namespace string and registers the namespace with the connection object, as in the previous example. </p>
<pre class="input">def example12():<br>    conn = example1()<br>    conn.clear()    <br>    exns = &quot;http://example.org/people/&quot;<br>    conn.setNamespace('ex', exns)</pre>
<p>We have to create an index. AllegroGraph lets you create any number of text indexes, each for a specific purpose. In this case we are indexing the literal values we find in the &quot;fullname&quot; predicate, which we will use in resources that describe people. The createFreeTextIndex() method has many configurable parameters. Their default settings are appropriate to this situation. All we have to provide is a name for the index and the URI of the predicate (or predicates) that contain the text to be indexed. </p>
<pre class="input">    conn.createFreeTextIndex(&quot;index1&quot;, predicates=[URI(namespace=exns, localname='fullname')])</pre>
<p>We can view the index configuration using the <strong>getFreeTextIndexConfiguration()</strong> method:  </p>
<pre class="input">    config = conn.getFreeTextIndexConfiguration(&quot;index1&quot;)<br>    print(config)<br>    for item in config[&quot;predicates&quot;]:<br>        print(item)</pre>
<p>The configuration object is a simple Python dictionary. Most of it is easy to interpret, but the predicate list has to be extracted before we see the actual predicates:</p>
<pre>{'indexLiterals': True, 'minimumWordSize': 3, 'indexFields': ['object'], 
'stopWords': ['and', 'are', 'but', 'for', 'into', 'not', 'such', 'that', 'the', 
'their', 'then', 'there', 'these', 'they', 'this', 'was', 'will', 'with'], 
'predicates': [&lt;franz.openrdf.model.value.URI object at 0x025831F0&gt;], 
'wordFilters': [], 'indexResources': False}
<br>&lt;http://example.org/people/fullname&gt;</pre>
<p>This configuration says that &quot;index1&quot; will operate on the literal values it finds in the object position of the <strong>&lt;http://example.org/people/fullname&gt;</strong> predicate. It ignores words smaller than three characters in length. It will ignore the worlds in its &quot;stopWords&quot; list. If it encounters a resource URI in the object position, it will ignore it. This index doesn't use any wordFilters, which are sometimes used to remove accented letters and to perform stemming on indexed text and search strings. </p>
<p>The next step is to create three new resources. One is a person, &quot;Alice,&quot; whose full name is &quot;Alice B. Toklas.&quot; There will also be a book, &quot;Alice in Wonderland,&quot; which is linked to an author resource, &quot;Lewis Carroll.&quot; The first step is to create some URIs and literal values: </p>
<pre class="input">    alice = conn.createURI(namespace=exns, localname=&quot;alice&quot;)<br>    carroll = conn.createURI(namespace=exns, localname=&quot;carroll&quot;)<br>    persontype = conn.createURI(namespace=exns, localname=&quot;Person&quot;)<br>    fullname = conn.createURI(namespace=exns, localname=&quot;fullname&quot;)    <br>    alicename = conn.createLiteral('Alice B. Toklas')
<br>    book =  conn.createURI(namespace=exns, localname=&quot;book1&quot;)<br>    booktype = conn.createURI(namespace=exns, localname=&quot;Book&quot;)<br>    booktitle = conn.createURI(namespace=exns, localname=&quot;title&quot;)<br>    author = conn.createURI(namespace=exns, localname=&quot;author&quot;)    <br>    wonderland = conn.createLiteral('Alice in Wonderland')
<br>    lewisCarroll = conn.createLiteral('Lewis Carroll')</pre>
<p>Add the resource for the new person, Alice B. Toklas: </p>
<pre class="input">    # Creating Alice B. Toklas resource <br>    conn.add(alice, RDF.TYPE, persontype)<br>    conn.add(alice, fullname, alicename)</pre>
<p>Add the new book, <em>Alice in Wonderland</em>. </p>
<pre class="input">    # Creating Alice in Wonderland book resource<br>    conn.add(book, RDF.TYPE, booktype)    <br>    conn.add(book, booktitle, wonderland) <br>    conn.add(book, author, carroll)</pre>
<p>Note that the book's author predicate links to the resource URI of the Lewis Carroll author resource. The author is a Person with a fullname:</p>
<pre class="input">    # Creating Lewis Carrol resource<br>    conn.add(carroll, fullname, lewisCarroll)<br>    conn.add(carroll, RDF.TYPE, persontype)</pre>
<p>Let's use getStatements() to retrieve the new triples and inspect them:</p>
<pre class="output">Current content of triple store:<br>(&lt;http://example.org/people/alice&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;)<br>(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/fullname&gt;, &quot;Alice B. Toklas&quot;)<br>
(&lt;http://example.org/people/book1&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Book&gt;)<br>(&lt;http://example.org/people/book1&gt;, &lt;http://example.org/people/title&gt;, &quot;Alice in Wonderland&quot;)<br>(&lt;http://example.org/people/book1&gt;, &lt;http://example.org/people/author&gt;, &lt;http://example.org/people/carroll&gt;)<br>
(&lt;http://example.org/people/carroll&gt;, &lt;http://example.org/people/fullname&gt;, &quot;Lewis Carroll&quot;)<br>(&lt;http://example.org/people/carroll&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/people/Person&gt;) </pre>
<p>Now we set up the SPARQL query that looks for triples containing &quot;Alice&quot; in the object position. </p>
<p>The text match occurs through a &quot;magic&quot; predicate called <strong>fti:match</strong>. This is not an RDF &quot;predicate&quot; but a LISP &quot;predicate,&quot; meaning that it behaves as a true/false test. This predicate  has two arguments. One is  the subject URI of the resources to search. The other is the string pattern to search for, such as &quot;Alice&quot;. Only full-word matches will be found. </p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o<br>    WHERE { ?s ?p ?o . 
            ?s fti:match 'Alice' . }<br>    &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    result = tupleQuery.evaluate(); </pre>
<p>There is no need to include a prefix declaration for the 'fti' nickname. That is because 'fti' is included among the built-in namespace/nickname mappings in AllegroGraph.</p>
<p>When we execute our SPARQL query, it matches the "Alice" within the literal "Alice B. Toklas" because that literal occurs in a triple having the <strong>fullname</strong> predicate, but it does not match the "Alice" in the literal "Alice in Wonderland" because the <strong>booktitle</strong> predicate was not included in our index. The SPARQL query returns <em>all of the triples of the matching resource</em>, not just the one that matched the text search. </p>
<pre class="input">    print &quot;Found %i query results&quot; % len(result)    <br>    count = 0<br>    for bindingSet in result:<br>        print bindingSet<br>        count += 1<br>        if count &gt; 5: break</pre>
<p>The output of this loop is:</p>
<pre class="output">Found 2 query results<br>{'p': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', 's': 'http://example.org/people/alice1', 'o': 'http://example.org/people/Person'}
{'p': 'http://example.org/people/fullname', 's': 'http://example.org/people/alice1', 'o': '&quot;Alice B. Toklas&quot;'}</pre>
<p>Note that the result set included both the matching triple and the<strong> rdf:type</strong> triple from the same resource. SPARQL returns the entire resource, not just the matching triple. </p>
<p>As it happens, the SPARQL interface to text search does not let you specify which index(es) to use, so SPARQL queries use <em>all</em> of the text indexes in the system. If you want to limit the search to a specific index, use the <strong>evalFreeTextSearch()</strong> method of the connection object:</p>
<pre class="input">    print(&quot;\nEvalFreeTextSearch() match 'Alice' in index1.&quot;)<br>    for triple in conn.evalFreeTextSearch(&quot;Alice&quot;, index=&quot;index1&quot;):<br>        print &quot; &quot; + str(triple)</pre>
<p>Unlike SPARQL, evalFreeTextSearch() returns only the matching triple:</p>
<pre class="output">EvalFreeTextSearch() match 'Alice' in index1.<br> ['&lt;http://example.org/people/alice&gt;', '&lt;http://example.org/people/fullname&gt;', '&quot;Alice B. Toklas&quot;']</pre>
<p>The text index supports simple wildcard queries. The asterisk (*) may be appended to the end of the pattern to indicate &quot;any number of additional characters.&quot; For instance, this query looks for whole words that begin with &quot;Ali&quot;:</p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o<br>    WHERE { ?s ?p ?o . ?s fti:match 'Ali*' . }<br>    &quot;&quot;&quot;</pre>
<p>It finds the same two triples as before.</p>
<p>There is also a single-character wildcard, the questionmark.  You can add as many question marks as you need to the string pattern.  This query looks for a five-letter word that has "l" in the second position, and "c" in the fourth position:</p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o<br>    WHERE { ?s ?p ?o . ?s fti:match '?l?c?' . }<br>    &quot;&quot;&quot;</pre>
<p>This query finds the same two triples as before. </p>
<p>This time we'll do something a little different.  The free text indexing matches whole words only, even when using wildcards. What if you really need to match a substring in a word of unknown length. You can write a SPARQL query that performs a regex match against object values. This can be inefficient compared to indexed search, and the match is not confined to the registered free-text predicates. The following query looks for the substring &quot;lic&quot; in literal object values:</p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>    SELECT ?s ?p ?o<br>    WHERE { ?s ?p ?o . FILTER regex(?o, &quot;lic&quot;) }<br>    &quot;&quot;&quot;</pre>
<p>This query returns two triples, but they are not quite the same as before:</p>
<pre class="output">Substring match for 'lic'<br>Found 2 query results<br>{'p': 'http://example.org/people/fullname', 's': 'http://example.org/people/alice1', 'o': '&quot;Alice B. Toklas&quot;'}<br>{'p': 'http://example.org/people/title', 's': 'http://example.org/people/book1', 'o': '&quot;Alice in Wonderland&quot;'} </pre>
<p>As you can see, the regex match found &quot;lic&quot; in &quot;Alice in Wonderland,&quot; which was not a registered free-text predicate. It made this match by doing a string comparison against every object value in the triple store. Even though you can streamline the SPARQL query considerably by writing more restrictive patterns, this is still inherently less efficient than using the indexed approach. </p>
<p>Note that evalFreeTextSearch() does not offer any way to do a regex substring search. </p>
<p>In addition to indexing literal values, AllegroGraph can also index resource URIs. &quot;Index2&quot; is an index that looks for URIs in the object position of the &quot;author&quot; predicate, and then indexes only the &quot;short&quot; name of the resource (the characters following the rightmost / or # in the URI). This lets us avoid indexing highly-repetitive namespace strings, which would fill the index with data that would not be very useful. </p>
<pre class="input">    conn.createFreeTextIndex(&quot;index2&quot;, predicates=[URI(namespace=exns, localname='author')],<br>                             indexResources=&quot;short&quot;, indexFields=[&quot;object&quot;])</pre>
<p>Now we'll search for the string &quot;Carroll&quot; in &quot;index2:&quot;</p>
<pre class="input">    print(&quot;\nMatch 'Carroll' in index2.&quot;)<br>    for triple in conn.evalFreeTextSearch(&quot;Carroll&quot;, index=&quot;index2&quot;):<br>        print &quot; &quot; + str(triple)</pre>
<pre class="output">
Match 'Carroll' in index2.<br> ['&lt;http://example.org/people/book1&gt;', '&lt;http://example.org/people/author&gt;', '&lt;http://example.org/people/carroll&gt;']
</pre>
<p>The text search located the triple that has &quot;Carroll&quot; in the URI in the object position. </p>
<h2 id="Ask, Describe, and Construct Queries">Select, Ask, Describe, and Construct Queries (example13())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>SPARQL provides alternatives to the standard SELECT query. Example example13() exercises these alternatives to show how AllegroGraph Server handles them. </p>
<ul>
  <li>    SELECT: Returns variables bound in a query pattern match. </li>
  <li>ASK: Returns a boolean indicating whether a query matches or not. </li>
  <li>CONSTRUCT: Returns triples constructed by substituting variables in a set of triple templates. </li>
  <li>DESCRIBE: Returns all of the triples of a matching resource. </li>
</ul>
<p>The example begins by borrowing a connection object from example6(). This connects to a repository that contains vcard and Kennedy data. We'll need to register a Kennedy namespace to make the queries easier to read. <pre class="input">def example13():<br>    conn = example6(False)  # kennedy and vcards data
    conn.setNamespace(&quot;kdy&quot;, &quot;http://www.franz.com/simple#&quot;)</pre>
<p>As it happens, we don't need the vcard data this time, so we'll remove it. This is an example of how to delete an entire subgraph (the vcards &quot;context&quot;):</p>
<pre class=input>    context = conn.createURI(&quot;http://example.org#vcards&quot;)<br>    conn.remove(None, None, None, context)</pre>
<p>The example begins with a SELECT query so we can see some of the Kennedy resources. </p>
<pre class="input">    queryString = &quot;&quot;&quot;select ?s where { ?s rdf:type kdy:person} limit 5&quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    result = tupleQuery.evaluate();<br>    print &quot;\nSELECT some persons&quot;<br>    for r in result: print r     </pre>
Note that SELECT returns variable bindings.  In this case it returns subject URIs of five people:
<pre class="output">SELECT some persons<br>{'s': u'&lt;http://www.franz.com/simple#person1&gt;'}<br>{'s': u'&lt;http://www.franz.com/simple#person2&gt;'}<br>{'s': u'&lt;http://www.franz.com/simple#person3&gt;'}<br>{'s': u'&lt;http://www.franz.com/simple#person4&gt;'}<br>{'s': u'&lt;http://www.franz.com/simple#person5&gt;'}</pre>
<p>The ASK query returns a Boolean, depending on whether the triple pattern matched any triples. In this case we ran two tests; one seeking &quot;John&quot; and the other looking for &quot;Alice.&quot; Note that the ASK query uses a different construction method than the SELECT query:<strong> prepareBooleanQuery()</strong>. </p>
<pre class="input">    queryString = &quot;&quot;&quot;ask { ?s kdy:first-name &quot;John&quot; } &quot;&quot;&quot;<br>    booleanQuery = conn.prepareBooleanQuery(QueryLanguage.SPARQL, queryString)<br>    result = booleanQuery.evaluate(); <br>    print &quot;\nASK: Is there anyone named John?&quot;, result
<br>    queryString = &quot;&quot;&quot;ask { ?s kdy:first-name &quot;Alice&quot; } &quot;&quot;&quot;<br>    booleanQuery = conn.prepareBooleanQuery(QueryLanguage.SPARQL, queryString)<br>    result = booleanQuery.evaluate(); <br>    print &quot;\nASK: Is there an Alice?&quot;, result</pre>
<p>The output of this loop is:</p>
<pre class="output">ASK: Is there anyone named John? True
ASK: Is there an Alice? False</pre>
<p>The CONSTRUCT query contructs a statement object out of the matching values in the triple pattern. A &quot;statement&quot; is a client-side triple. Construction queries use <strong>prepareGraphQuery()</strong>. The point is that the query can bind variables from existing triples and then &quot;construct&quot; a<em> new triple</em> by recombining the values. This query constructs new triples using a <strong>kdy:has-grandchild</strong> predicate. </p>
<pre class="input">    queryString = &quot;&quot;&quot;<br>	construct {?a kdy:has-grandchild ?c} <br>	where { ?a kdy:has-child ?b . <br>	        ?b kdy:has-child ?c . } <br>	        &quot;&quot;&quot;<br>    constructQuery = conn.prepareGraphQuery(QueryLanguage.SPARQL, queryString)<br>    result = constructQuery.evaluate(); </pre>
<p>The CONSTRUCT query does not actually add the new triples to the store. You have to iterate through the results and add them yourself: </p>
<pre class="input">    print &quot;/nConstruct result, creating new has-grandchild triples:&quot;<br>    for st in result:<br>        conn.add(st.getSubject(), st.getPredicate(), st.getObject())</pre>
<p>The DESCRIBE query returns a &quot;graph,&quot; meaning all triples of the matching resources.  It uses <strong>prepareGraphQuery()</strong>. In this case we asked SPARQL to describe one grandparent and one grandchild. (This confirms that the kdy:has-grandchild triples successfully entered the triple store.) </p>
<pre class="input">    queryString = &quot;&quot;&quot;describe ?s ?o where { ?s kdy:has-grandchild ?o . } limit 1&quot;&quot;&quot;<br>    describeQuery = conn.prepareGraphQuery(QueryLanguage.SPARQL, queryString)<br>    result = describeQuery.evaluate(); <br>    print &quot;Describe one grandparent and one grandchild:&quot;<br>    for st in result: print st </pre>
<p>The output of this loop is lengthy, because the Kennedy resources have many triples. One block of triples looked like this, showing the new has-grandchild triples: </p>
<pre class="output">(&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#has-grandchild&gt;, &lt;http://www.franz.com/simple#person20&gt;)<br>(&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#has-grandchild&gt;, &lt;http://www.franz.com/simple#person22&gt;)<br>(&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#has-grandchild&gt;, &lt;http://www.franz.com/simple#person24&gt;)<br>(&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#has-grandchild&gt;, &lt;http://www.franz.com/simple#person25&gt;)<br>(&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#has-grandchild&gt;, &lt;http://www.franz.com/simple#person26&gt;)</pre>
<h2 id="Parametric Queries">Parametric Queries (example14())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
 <p>The Python Sesame API to AllegroGraph Server lets you set up a SPARQL query and then fix the value of one of the query variables prior to matching the triples. This is more efficient than testing for the same value in the body of the query. </p>
 <p>In <strong>example14()</strong> we set up two-triple resources for Bob and Alice, and then use an unconstrained SPARQL query to retrieve the triples. Normally this query would find all four triples, but by binding the subject value ahead of time, we can retrieve the &quot;Bob&quot; triples separately from the &quot;Alice&quot; triples.</p>
 <p>The example begins by borrowing a connection object from example2(). This means there are already Bob and Alice resources in the repository. We do need to recreate the URIs for the two resources, however. </p>
 <pre class="input">def example14():<br>    conn = example2()<br>    alice = conn.createURI(&quot;http://example.org/people/alice&quot;)<br>    bob = conn.createURI(&quot;http://example.org/people/bob&quot;)</pre>
<p>The SPARQL query is the simple, unconstrained query that returns all triples. We use <strong>prepareTupleQuery()</strong> to create the query object. </p>
<pre class="input">
    queryString = &quot;&quot;&quot;select ?s ?p ?o where { ?s ?p ?o} &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)</pre>
<p>Before evaluating the query, however, we'll use the query object's <strong>setBinding()</strong> method to assign Alice's URI to the &quot;s&quot; variable in the query. This means that all matching triples are required to have Alice's URI in the subject position of the triple. </p>
<pre class="input">
    tupleQuery.setBinding(&quot;s&quot;, alice)<br>    result = tupleQuery.evaluate()    <br>    print &quot;Facts about Alice:&quot;<br>    for r in result: print r  </pre>
<p>The output of this loop consists of all triples that describe Alice:</p>
<pre class="output">Facts about Alice:<br>{'p': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', 's': 'http://example.org/people/alice', 'o': 'http://example.org/ontology/Person'}
{'p': 'http://example.org/ontology/name', 's': 'http://example.org/people/alice', 'o': '&quot;Alice&quot;'}</pre>
<p>Now we'll run the same query again, but this time we'll constrain &quot;s&quot; to be Bob's URI. The query will return all triples that describe Bob. </p>
<pre class="input">
    tupleQuery.setBinding(&quot;s&quot;, bob)<br>    print &quot;Facts about Bob:&quot;    <br>    result = tupleQuery.evaluate()<br>    for r in result: print r  
</pre>
 The output of this loop is:
 <pre class="output">Facts about Bob:<br>{'p': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', 's': 'http://example.org/people/bob', 'o': 'http://example.org/ontology/Person'}
{'p': 'http://example.org/ontology/name', 's': 'http://example.org/people/bob', 'o': '&quot;Bob&quot;'}</pre>
 <h2 id="Range Matches">Range Matches (example15())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
 <p>Example15() demonstrates how to set up a query that matches a range of values. In this case, we'll retrieve all people between 30 and 50 years old (inclusive). We can accomplish this using the connection object's <strong>createRange()</strong> method. </p>
 <p>This example begins by getting a connection object from example1(), and then clearing the repository of the existing triples. </p>
 <pre class="input">
def example15():<br>    conn = example1()<br>    conn.clear()</pre>
<p>Then we register a namespace to use in the query. </p>
<pre class="input">
    exns = &quot;http://example.org/people/&quot;<br>    conn.setNamespace('ex', exns)</pre>
<p>Next we need to set up the URIs for Alice, Bob, Carol and the predicate &quot;age&quot;. </p>
<pre class="input">
    alice = conn.createURI(namespace=exns, localname=&quot;alice&quot;)<br>    bob = conn.createURI(namespace=exns, localname=&quot;bob&quot;)<br>    carol = conn.createURI(namespace=exns, localname=&quot;carol&quot;)    <br>    age = conn.createURI(namespace=exns, localname=&quot;age&quot;)    </pre>
<p>In this step, we use the connection's createRange() method to generate a range object with limits 30 and 50:</p>
<pre class="input">    range = conn.createRange(30, 50)</pre>
<p>The next two lines are essential to the experiment, but you can take your pick of which one to use. The range comparison requires that all of the matching values must have the same datatype. In this case, the values must all be ints. The connection object lets us force this uniformity on the data through the <strong>registerDatatypeMapping()</strong> method. You can force all values of a specific predicate to be internally represented as one datatype, as we do here: </p>
<pre class="input">
    conn.registerDatatypeMapping(predicate=age, nativeType=&quot;int&quot;)</pre>
<p>This line declares that all values of the age predicate will be represented in triples as if they were &quot;int&quot; values in Python. </p>
<pre class="input">
    conn.registerDatatypeMapping(datatype=XMLSchema.INT, nativeType=&quot;int&quot;)    </pre>
<p>However, this doesn't mean quite what you think it does. As it happens, due to implementation details that differ between Python and AllegroGraph, the closest AllegroGraph datatype to Python's &quot;int&quot; is XMLSchema.LONG. When we create the following triples, we find that they contain XMLSchema.LONG values. </p>
<pre class="input">    conn.add(alice, age, 42)
    conn.add(bob, age, 24) <br>    conn.add(carol, age, &quot;39&quot;) 
</pre>
<p>The next step is to use getStatements() to retrieve all triples where the age value is between 30 and 50. </p>
<pre class="input">    statements = conn.getStatements(None, age, range)<br>    for s in statements:<br>        print s</pre>
<p>The output of this loop is:</p>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/age&gt;, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;)
(&lt;http://example.org/people/carol&gt;, &lt;http://example.org/people/age&gt;, &quot;39&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;)</pre>
<p>The range query  has matched 42 and &quot;39&quot;, but not 24. </p>

<h2 id="Federated Repositories">Federated Repositories (example16())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph lets you split up your triples among repositories on multiple servers and then search them all in parallel. To do this we query a single &quot;federated&quot; repository that automatically distributes the queries to the secondary repositories and combines the results. From the point of view of your Python code, it looks like you are working with a single repository. </p>
<p>Example16() begins by defining a small output function that we'll use at the end of the lesson. It prints out responses from different repositories. This example is about red apples and green apples, so the output function talks about apples. </p>
<pre class="input">def example16():<br>    def pt(kind, rows, expected):<br>        print &quot;\n%s Apples:\t&quot; % kind.capitalize(),<br>        for r in rows: print r[0].getLocalName(),</pre>
<p>In the next block of code, we open connections to a redRepository and a greenRepository on the local server. In a typical federation scenario, these respositories would be distributed across multiple servers. </p>
<pre class="input">    server = AllegroGraphServer(AG_HOST, AG_PORT, 'test', 'xyzzy')<br>    catalog = server.openCatalog(AG_CATALOG)<br>    ## create two ordinary stores, and one federated store: <br>    redConn = catalog.getRepository(&quot;redthings&quot;, Repository.RENEW).initialize().getConnection()<br>    greenConn = catalog.getRepository(&quot;greenthings&quot;, Repository.RENEW).initialize().getConnection()</pre>
<p>Now we create a &quot;federated&quot; respository, which is connected to the distributed repositories at the back end. When we open a federated repository, AllegroGraph creates a session and returns a connection: </p>
<pre class="input">    rainbowThings = server.openFederated([redConn, greenConn], True)</pre>
<p>It is necessary to register the &quot;ex&quot; namespace in all three repositories so we can use it in the upcoming query. </p>
<pre class="input">    ex = &quot;http://www.demo.com/example#&quot;<br>    redConn.setNamespace('ex', ex)<br>    greenConn.setNamespace('ex', ex)<br>    rainbowThings.setNamespace('ex', ex)        </pre>
<p>The next step is to populate the Red and Green repositories with a few triples. Note that one of the green objects is not an apple: </p>
<pre class="input">    redConn.add(redConn.createURI(ex+&quot;mcintosh&quot;), RDF.TYPE, redConn.createURI(ex+&quot;Apple&quot;))<br>    redConn.add(redConn.createURI(ex+&quot;reddelicious&quot;), RDF.TYPE, redConn.createURI(ex+&quot;Apple&quot;))    <br>    greenConn.add(greenConn.createURI(ex+&quot;pippin&quot;), RDF.TYPE, greenConn.createURI(ex+&quot;Apple&quot;))<br>    greenConn.add(greenConn.createURI(ex+&quot;kermitthefrog&quot;), RDF.TYPE, greenConn.createURI(ex+&quot;Frog&quot;))</pre>
<p>Let's check to see if the federated session can &quot;see&quot; the new triples:</p>
<pre class="input">        print &quot;\nFederated size: &quot; + str(rainbowThings.size())</pre>
<pre class="output">Federated size: 4</pre>
<p>This tells us that the federated store can see the triples in the component stores. Now we write a query that retrieves Apples from the Red repository, the Green repository, and the federated repository, and prints out the results. </p>
<pre class="input">
    queryString = &quot;select ?s where { ?s rdf:type ex:Apple }&quot;<br>    ## query each of the stores; observe that the federated one is the union of the other two:<br>    pt(&quot;red&quot;, redConn.prepareTupleQuery(QueryLanguage.SPARQL, queryString).evaluate())<br>    pt(&quot;green&quot;, greenConn.prepareTupleQuery(QueryLanguage.SPARQL, queryString).evaluate())<br>    pt(&quot;federated&quot;, rainbowConn.prepareTupleQuery(QueryLanguage.SPARQL, queryString).evaluate()) </pre>
<p>The output is shown below. The federated response combines the individual responses. </p>
<pre class="output">Red Apples:   reddelicious mcintosh <br>Green Apples:   pippin <br>Federated Apples:   reddelicious mcintosh pippin</pre>
<p>It should go without saying that a search for apples does not turn up a frog. </p>
<h2 id="Prolog Rule Queries">Prolog Rule Queries (example17())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph Server lets us load Prolog backward-chaining rules to make query-writing simpler.&nbsp; The Prolog rules let us write the queries in terms of higher-level concepts.&nbsp; When a query refers to one of these concepts, Prolog rules become active in the background to determine if the concept is valid in the current context.&nbsp; </p>
<p>For instance, in this example the query says that the matching resource must be a &quot;man&quot;.&nbsp; A Prolog rule examines the matching resources to see which of them are persons who are male.&nbsp; The query can proceed for those resources. The rules provide a level of abstraction that makes the queries simpler to express. </p>
<p>The example17() example begins by borrowing a connection object from example example6(), which contains the Kennedy family tree.&nbsp; Note that example6() creates a <a href="#Transaction Control">dedicated session</a> for the rules to operate in, using the Connection object's <strong>openSession()</strong> method. Python rules cannot be loaded into the AllegroGraph common back end. </p>
<pre class="input">conn.openSession(); # in example6()</pre>
<p>This converts the connection to a &quot;dedicated&quot; connection. After that step, all of the code is exactly the same as when using the common back end.</p>
<pre class="input">def example17():<br>    conn = example6()  #obtain dedicated connection from example6()</pre>
<p>We will need the same namespace as we used in the Kennedy example. </p>
<pre class="input">
    conn.setNamespace(&quot;kdy&quot;, &quot;http://www.franz.com/simple#&quot;)</pre>
<p>These are the &quot;man&quot; and &quot;woman&quot; rules.&nbsp; A resource represents a &quot;woman&quot; if the resource contains a sex=female triple and an rdf:type = person triple.&nbsp; A similar deduction identifies a &quot;man&quot;.&nbsp; The &quot;q&quot; at the beginning of each pattern simply stands for &quot;query&quot; and introduces a triple pattern. </p>
<pre class="input">    rules1 = &quot;&quot;&quot;<br>    (&lt;-- (woman ?person) ;; IF<br>         (q ?person !kdy:sex !kdy:female)<br>         (q ?person !rdf:type !kdy:person))<br>    (&lt;-- (man ?person) ;; IF<br>         (q ?person !kdy:sex !kdy:male)<br>         (q ?person !rdf:type !kdy:person))<br>    &quot;&quot;&quot;</pre>
<p>The rules must be explicitly added to the dedicated session. </p>
<pre class="input">
    conn.addRules(rules1)</pre>
<p>This is the query.&nbsp; This query locates all the &quot;man&quot; resources, and retrieves their first and last names. </p>
<pre class="input">
    queryString = &quot;&quot;&quot;<br>    (select (?first ?last)<br>            (man ?person)<br>            (q ?person !kdy:first-name ?first)<br>            (q ?person !kdy:last-name ?last)<br>            )<br>    &quot;&quot;&quot;</pre>
<p>Here we perform the query and retrieve the result object.&nbsp; </p>
<pre class="input">    tupleQuery = conn.prepareTupleQuery(QueryLanguage.PROLOG, queryString)<br>    result = tupleQuery.evaluate();     </pre>
<p>The result object contains multiple bindingSets.&nbsp; We can iterate over them to print out the values. </p>
<pre class="input">
    for bindingSet in result:<br>        f = bindingSet.getValue(&quot;first&quot;)<br>        l = bindingSet.getValue(&quot;last&quot;)<br>        print &quot;%s %s&quot; % (f.toPython(), l.toPython())</pre>
<p>The output contains many names; there are just a few of them. </p>
<pre class="output">Robert Kennedy<br>Alfred Tucker<br>Arnold Schwarzenegger<br>Paul Hill<br>John Kennedy</pre>
<p>It is good form to close the dedicated session when you are finished with it.</p>
<pre class="input">    conn.closeDedicated()</pre>
<h2 id="Loading Prolog Rules">Loading Prolog Rules (example18())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>Example <strong>example18()</strong> demonstrates how to load a file of Prolog rules into the Python Sesame API of AllegroGraph Server.&nbsp; It also demonstrates how robust a rule-augmented system can become.&nbsp; The domain is the Kennedy family tree again, borrowed from example6().&nbsp; After loading a file of rules (<strong>python-rules.txt</strong>), we'll pose a simple query.&nbsp; The query asks AllegroGraph to list all the uncles in the family tree, along with each of their nieces or nephews.&nbsp; This is the query:</p>
<pre class="input">(select (?ufirst ?ulast ?cfirst ?clast)<br>        (uncle ?uncle ?child)<br>        (name ?uncle ?ufirst ?ulast)<br>        (name ?child ?cfirst ?clast))</pre>
<p>The problem is that the triple store contains no information about uncles.&nbsp; The rules will have to deduce this relationship by finding paths across the RDF graph.&nbsp; </p>
<p>What's an &quot;uncle,&quot; then?&nbsp; Here's a rule that can recognize uncles:</p>
<pre class="input">(&lt;-- (uncle ?uncle ?child) <br>    (man ?uncle)<br>    (parent ?grandparent ?uncle)<br>    (parent ?grandparent ?siblingOfUncle)<br>    (not (= ?uncle ?siblingOfUncle))<br>    (parent ?siblingOfUncle ?child))</pre>
<p>The rule says that an &quot;uncle&quot; is a &quot;man&quot; who has a sibling who is the &quot;parent&quot; of a child.&nbsp; (Rules like this always check to be sure that the two nominated siblings are not the same resource.) Note that none of these relationships are triple patterns. They all deal in higher-order concepts. We'll need additional rules to determine what a &quot;man&quot; is, and what a &quot;parent&quot; is.</p>
<p>What is a &quot;parent?&quot; It turns out that there are two ways to be classified as a parent:</p>
<pre class="input">(&lt;-- (parent ?father ?child)<br>    (father ?father ?child))

(&lt;-- (parent ?mother ?child)<br>    (mother ?mother ?child))</pre>
<p>A person is a &quot;parent&quot; if a person is a &quot;father.&quot;&nbsp; Similarly, a person is a &quot;parent&quot; if a person is a &quot;mother.&quot; </p>
<p>What's a &quot;father?&quot;</p>
<pre class="input">(&lt;-- (father ?parent ?child)<br>    (man ?parent)<br>    (q ?parent !rltv:has-child ?child))</pre>
<p>A person is a &quot;father&quot; if the person is &quot;man&quot; and has a child. &nbsp; The final pattern (beginning with &quot;q&quot;) is a triple match from the Kennedy family tree.</p>
<p>What's a &quot;man?&quot;</p>
<pre class="input">(&lt;-- (man ?person)<br>    (q ?person !rltv:sex !rltv:male)<br>    (q ?person !rdf:type !rltv:person))</pre>
<p>A &quot;man&quot; is a person who is male.&nbsp; These patterns both match triples in the repository.&nbsp; </p>
<p>The<strong> python_rules.txt</strong> file contains many more Prolog rules describing relationships, including transitive relationships like &quot;ancestor&quot; and &quot;descendant.&quot; Please examine this file for more ideas about how to use rules with AllegroGraph. </p>
<p>The <strong>example18()</strong> example begins by borrowing a connection object from example6(), which means the Kennedy family tree is already loaded into the repository, and we are dealing with a <a href="#Transaction Control">dedicated session</a>. &nbsp; </p>
<pre class="input">def example18():<br>    conn = example6()</pre>
<p>We need these two namespaces because they are used in the query and in the file of rules. </p>
<pre class="input">
    conn.setNamespace(&quot;kdy&quot;, &quot;http://www.franz.com/simple#&quot;)<br>    conn.setNamespace(&quot;rltv&quot;, &quot;http://www.franz.com/simple#&quot;)  </pre>
<p>The next step is to load the rule file: </p>
<pre class="input">
    path = &quot;./python_rules.txt&quot;<br>    conn.loadRules(path)</pre>
<p>The query asks for the first and last names of each uncle and each niece/nephew.&nbsp; The name strings are provided by another Prolog rule: </p>
<pre class="input">    queryString = &quot;&quot;&quot;(select (?ufirst ?ulast ?cfirst ?clast)<br>                             (uncle ?uncle ?child)<br>                             (name ?uncle ?ufirst ?ulast)<br>                             (name ?child ?cfirst ?clast))&quot;&quot;&quot;</pre>
<p>Here we execute the query and display the results. The code is a little more complicated than usual because of the string concatenations that build the names. </p>
<pre class="input">    tupleQuery = conn.prepareTupleQuery(QueryLanguage.PROLOG, queryString)<br>    result = tupleQuery.evaluate();     <br>    for bindingSet in result:<br>        u1 = bindingSet.getValue(&quot;ufirst&quot;)<br>        u2 = bindingSet.getValue(&quot;ulast&quot;)<br>        ufull = u1.toPython() + &quot; &quot; + u2.toPython()<br>        c1 = bindingSet.getValue(&quot;cfirst&quot;)<br>        c2 = bindingSet.getValue(&quot;clast&quot;)<br>        cfull = c1.toPython() + &quot; &quot; + c2.toPython()<br>        print &quot;%s is the uncle of %s.&quot; % (ufull, cfull)</pre>
<p>The output of this loop (in part) looks like this:
<pre class="output">Robert Kennedy is the uncle of Amanda Smith.<br>Robert Kennedy is the uncle of Kym Smith.<br>Edward Kennedy is the uncle of Robert Shriver.<br>Edward Kennedy is the uncle of Maria Shriver.<br>Edward Kennedy is the uncle of Timothy Shriver.</pre>
<p>As before, it is good form to close the dedicated session when you are finished with it.</p>
<pre class="input">    conn.closeSession()<br>    conn.close();<br>    myRepository = conn.repository<br>    myRepository.shutDown()</pre>

<h2 id="RDFS++ Inference">RDFS++ Inference (example19())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The great promise of the semantic web is that we can use RDF metadata to combine information from multiple sources into a single, common model.&nbsp; The great problem of the semantic web is that it is so difficult to recognize when two resource descriptions from different sources actually represent the same thing.&nbsp; This problem arises because there is no uniform or universal way to generate URIs identifying resources.&nbsp; As a result, we may create two resources, Bob and Robert, that actually represent the same person. </p>
<p>This problem has generated much creativity in the field. One way to approach the problem is through inference.&nbsp; There are certain relationships and circumstances where an inference engine can deduce that two resource descriptions actually represent one thing, and then automatically merge the descriptions.&nbsp; AllegroGraph's <a href="../reasoner-tutorial.html">inference engine</a> can be turned on or off each time you run a query against the triple store.&nbsp; (Note that inference is turned off by default, which is the opposite of standard Sesame behavior.) </p>
<p>In example example19(), we will create four resources: Bob, with son Bobby, and Robert with daughter Roberta.&nbsp; </p>
<p><img src="inferenceSetup.jpg" width="448" height="101"></p>
<p>First we have to set up the data. We begin by generating four URIs for the new resources. </p>
<pre class="input">    ## Create URIs for Bob and Robert (and kids) 
    robert = conn.createURI(&quot;http://example.org/people/robert&quot;)
	roberta = conn.createURI(&quot;http://example.org/people/roberta&quot;)
	bob = conn.createURI(&quot;http://example.org/people/bob&quot;)
	bobby = conn.createURI(&quot;http://example.org/people/bobby&quot;)
</pre>
The next step is to create URIs for the predicates we'll need (<em>name</em> and <em>fatherOf</em>), plus one for the Person class. <br>
<pre class="input">    ## create name and child predicates, and Person class.<br>    name = conn.createURI(&quot;http://example.org/ontology/name&quot;)<br>    fatherOf = conn.createURI(&quot;http://example.org/ontology/fatherOf&quot;)<br>    person = conn.createURI(&quot;http://example.org/ontology/Person&quot;)
</pre>
The names of the four people will be literal values. <br>
<pre class="input">    ## create literal values for names    <br>    bobsName = conn.createLiteral(&quot;Bob&quot;)<br>    bobbysName = conn.createLiteral(&quot;Bobby&quot;)<br>    robertsName = conn.createLiteral(&quot;Robert&quot;)<br>    robertasName = conn.createLiteral(&quot;Roberta&quot;)
</pre>
<p>Robert, Bob and the children are all instances of class Person.&nbsp; It is good practice to identify all resources by an rdf:type link to a class.</p>
<pre class="input">    ## Robert, Bob, and children are people<br>    conn.add(robert, RDF.TYPE, person)<br>    conn.add(roberta, RDF.TYPE, person)<br>    conn.add(bob, RDF.TYPE, person)<br>    conn.add(bobby, RDF.TYPE, person)
</pre>
The four people all have literal names. <br>
<pre class="input">    ## They all have names.<br>    conn.add(robert, name, robertsName)<br>    conn.add(roberta, name, robertasName)<br>    conn.add(bob, name, bobsName)<br>    conn.add(bobby, name, bobbysName)
</pre> 
Robert and Bob have links to the child resources:
<br>
<pre class="input">    ## robert has a child<br>    conn.add(robert, fatherOf, roberta)<br>    ## bob has a child<br>    conn.add(bob, fatherOf, bobby)
</pre> 
<h3>SameAs, using a SPARQL Query </h3>
<p>Now that the basic resources and relations are in place, we'll seed the triple store with a statement that &quot;Robert is the same as Bob,&quot; using the <strong>owl:sameAs</strong> predicate.&nbsp; The AllegroGraph inference engine recognizes the semantics of owl:sameAs, and automatically infers that Bob and Robert share the same attributes.&nbsp; Each of them originally had one child.&nbsp; When inference is turned on, however, they each have two children.&nbsp; </p>
<p><img src="inferenceSaveAs.jpg" width="459" height="182"></p>
<p>Note that SameAs does not combine the two resources.&nbsp; Instead it links each of the two resources to all of the combined children.&nbsp; The red links in the image are &quot;inferred&quot; triples.&nbsp; They have been deduced to be true, but are not actually present in the triple store. </p>
<p>This is the critical link that tells the inference engine to regard Bob and Robert as the same resource. </p>
<pre class="input">    ## Bob is the same person as Robert<br>    conn.add(bob, OWL.SAMEAS, robert)
</pre>
<p>This is a simple SPARQL query asking for the children of Robert, with inference turned OFF. Note the use of <strong>tupleQuery.setIncludeInferred()</strong>, which controls whether or not inferred triples may be included in the query results. Inference is turned off by default, but for teaching purposes we have turned it of explicitly. We also took the liberty of setting variable bindings for ?robert and ?fatherOf, simply to make the code easier to read. Otherwise we would have had to put full-length URIs in the query string. </p>
<pre class="input">    queryString = <strong>&quot;SELECT ?child WHERE {?robert ?fatherOf ?child .}&quot;</strong><br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString)<br>    <strong>tupleQuery.setIncludeInferred(False)</strong> # Turn off inference<br>    tupleQuery.setBinding(&quot;robert&quot;, robert)<br>    tupleQuery.setBinding(&quot;fatherOf&quot;, fatherOf)<br>    result = tupleQuery.evaluate()    <br>    print &quot;Children of Robert, inference OFF:&quot;<br>    for r in result: print r  </pre> 
<p>The search returns one triple, which is the link from Robert to his direct child, Roberta. </p>
<pre class="output">Children of Robert, inference OFF
{'child': u'&lt;http://example.org/people/roberta&gt;'}</pre>
<p>Now we'll perform the same query (the same tupleQuery, in fact), with inference turned ON.&nbsp; </p>
<pre class="input">    tupleQuery.setIncludeInferred(True)<br>    result = tupleQuery.evaluate()    <br>    print &quot;Children of Robert, inference ON:&quot;<br>    for r in result: print r  </pre>
<pre class="output">Children of Robert, inference ON
{'child': u'&lt;http://example.org/people/roberta&gt;'}<br>{'child': u'&lt;http://example.org/people/bobby&gt;'}</pre>
<p>Note that with inference ON, Robert suddenly has two children because Bob's child has been included.&nbsp; Also note that the final triple (robert fatherOf bobby) has been inferred.&nbsp; The inference engine has determined that this triple logically must be true, even though it does not appear in the repository. </p>
<h3>InverseOf</h3>
<p>We can reuse the Robert family tree to see how the inference engine can deduce the presence of inverse relationships. </p>
<p>Up to this point in this tutorial, we have created new predicates simply by creating a URI and using it in the predicate position of a triple.&nbsp; This time we need to create a predicate<em> resource</em> so we can set an attribute of that resource.&nbsp; We're going to declare that the <strong>hasFather</strong> predicate is the <strong>owl:inverseOf</strong> the existing fatherOf predicate. </p>
<p>The first step is to remove the owl:sameAs link, because we are done with it. </p>
<pre class="input">    conn.remove(bob, OWL.SAMEAS, robert)
</pre>
<p>We'll need a URI for the new hasFather predicate:</p>

<pre class="input">    hasFather = conn.createURI("http://example.org/ontology/hasFather")</pre>
<p>This is the line where we create a predicate resource.&nbsp; It is just a triple that describes a property of the predicate.&nbsp; The hasFather predicate is the inverse of the fatherOf predicate: </p>

<pre class="input">     conn.add(hasFather, OWL.INVERSEOF, fatherOf)</pre>
<p>For this example, we're going to use <strong>getStatements()</strong> instead of SPARQL. The simple getStatements() format is sufficient to our needs, and simplifies the code. First, we'll search for hasFather triples, leaving inference OFF to show that there are no such triples in the repository. The fifth parameter to getStatements(), shown here as <strong>False</strong>, controls inferencing. </p>

<pre class="input">    print "People with fathers, inference OFF"
    for s in conn.getStatements(None, hasFather, None, None, <strong>False</strong>): print s    
</pre>
<pre class="output">People with fathers, inference OFF<br></pre>
<p>Now we'll turn inference ON by changing the fifth parameter to <strong>True</strong>. This time, the AllegroGraph inference engine discovers two &quot;new&quot; hasFather triples. </p>
<pre class="input">    print "People with fathers, inference ON"
    for s in conn.getStatements(None, hasFather, None, None, <strong>True</strong>): print s  
</pre>
<pre class="output">People with fathers, inference ON<br>(&lt;http://example.org/people/bobby&gt;, &lt;http://example.org/ontology/hasFather&gt;, &lt;http://example.org/people/bob&gt;)
(&lt;http://example.org/people/roberta&gt;, &lt;http://example.org/ontology/hasFather&gt;, &lt;http://example.org/people/robert&gt;)</pre>
<p>Both of these triples are inferred by the inference engine.</p>
<h3>SubPropertyOf</h3>
<p>Invoking inference using the <strong>rdfs:subPropertyO</strong>f predicate lets us &quot;combine&quot; two predicates so they can be searched as one.&nbsp; For instance, in our Robert/Bob example, we have explicit fatherOf relations.&nbsp; Suppose there were other resources that used a parentOf relation instead of fatherOf.&nbsp; By making fatherOf a subproperty of parentOf, we can search for parentOf triples and automatically find the fatherOf triples at the same time. </p>
<p>First we should remove the owl:inverseOf relation from the previous example. We don't have to, but it keeps things simple. </p>
<pre class="input">    ## Remove owl:inverseOf property.<br>    conn.remove(hasFather, OWL.INVERSEOF, fatherOf) </pre>
<p>We'll need a parentOf URI to use as the new predicate.&nbsp; Then we'll add a triple saying that fatherOf is an rdfs:subPropertyOf the new predicate, parentOf:</p>
<pre class="input">    parentOf = conn.createURI(&quot;http://example.org/ontology/parentOf&quot;)<br>    conn.add(fatherOf, RDFS.SUBPROPERTYOF, parentOf)
</pre>
<p>If we now search for parentOf triples with inference OFF, we won't find any. No such triples exist in the repository. </p>
<pre class="input">    print &quot;People with parents, inference OFF&quot;<br>    for s in conn.getStatements(None, parentOf, None, None, False): print s   
</pre><pre class="output">People with parents, inference OFF

</pre>
<p>With inference ON, however, AllegroGraph infers two new triples: </p>
<pre class="input">
    print &quot;People with parents, inference ON&quot;<br>    for s in conn.getStatements(None, parentOf, None, None, True): print s  
</pre>
<pre class="output">People with parents, inference ON<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/ontology/parentOf&gt;, &lt;http://example.org/people/bobby&gt;)<br>(&lt;http://example.org/people/robert&gt;, &lt;http://example.org/ontology/parentOf&gt;, &lt;http://example.org/people/roberta&gt;)</pre>
<p>The fact that two fatherOf triples exist means that two correponding parentOf triples must be valid.&nbsp; There they are.</p>
<p>Before setting up the next example, we should clean up:</p>
<pre class="input">conn.remove(fatherOf, RDFS.SUBPROPERTYOF, parentOf) </pre>
<h3>Domain and Range</h3>
<p>When you declare the domain and range of a predicate, the AllegroGraph inference engine can infer the rdf:type of resources found in the subject and object positions of the triple.&nbsp; For instance, in the triple &lt;<em>subject</em>, fatherOf, <em>object</em>&gt; we know that the <em>subject</em> is always an instance of class Parent, and the <em>object</em> is always an instance of class Child.&nbsp;</p>
<p>In RDF-speak, we would say that the <strong>domain</strong> of the fatherOf predicate is rdf:type Parent.&nbsp; The <strong>range</strong> of fatherOf is rdf:type Child.&nbsp; </p>
<p>This lets the inference engine determine the rdf:type of every resource that participates in a fatherOf relationship.&nbsp; </p>
<p>We'll need two new classes, Parent and Child.&nbsp; Note that RDF classes are always capitalized, just as predicates are always lowercase.</p>
<pre class="input">    parent = conn.createURI(&quot;http://example.org/ontology/Parent&quot;)<br>    child = conn.createURI(&quot;http://exmaple.org/ontology/Child&quot;)
</pre>
<p>Now we add two triples defining the domain and rage of the fatherOf predicate: </p><pre class="input">    conn.add(fatherOf, RDFS.DOMAIN, parent)<br>    conn.add(fatherOf, RDFS.RANGE, child)
</pre>
<p>Now we'll search for resources of rdf:type Parent.&nbsp; The inference engine supplies the appropriate triples: </p>
<pre class="input">    print &quot;Who are the parents?  Inference ON.&quot;<br>    for s in conn.getStatements(None, RDF.TYPE, parent, None, True): print s
</pre><pre class="output">
Who are the parents?  Inference ON.
(&lt;http://example.org/people/bob&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/ontology/Parent&gt;
(&lt;http://example.org/people/robert&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://example.org/ontology/Parent&gt;)
</pre>
<p>Bob and Robert are parents.&nbsp; Who are the children? </p>
<pre class="input">&nbsp;   print &quot;Who are the children?  Inference ON.&quot;<br>    for s in conn.getStatements(None, RDF.TYPE, child, None, True): print s
</pre><pre class="output">Who are the children?  Inference ON.
(&lt;http://example.org/people/bobby&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://exmaple.org/ontology/Child&gt;)
(&lt;http://example.org/people/roberta&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://exmaple.org/ontology/Child&gt;)</pre>
<p>Bobby and Roberta are the children.&nbsp;  </p>
<h2 id="Geospatial Search">Geospatial Search (example20())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph provides the ability to locate resources within a geospatial coordinate system. You can set up either a flat (X,Y Cartesian) or spherical (latitude, longitude) system. The systems are two-dimensional only. (There is no Z or altitude dimension available). </p>
<p>The purpose of the geospatial representation is to efficiently find all entities that are located within a specific circular, rectangular or polygonal area. </p>
<h3>Cartesian System </h3>
<p>A Cartesian system is a flat (X,Y) plane. Locations are designated by (X,Y) pairs. At this time, AllegroGraph does not support real-world measurement units (km, miles, latitude, etc.,) in the Cartesian system. </p>
<p>The first example uses a Cartesian (X,Y) system that is 100 units square, and contains three people located at various points along the X = Y diagonal.</p>
<p><img src="gepCartesian.jpg" width="417" height="333"> </p>
<p>The example is in the function example20(). After establishing a connection, it begins by creating URIs for the three people.</p>
<pre class="input">    exns = &quot;http://example.org/people/&quot;<br>    conn.setNamespace('ex', exns)<br>    alice = conn.createURI(exns, &quot;alice&quot;)<br>    bob = conn.createURI(exns, &quot;bob&quot;)<br>    carol = conn.createURI(exns, &quot;carol&quot;)</pre>
<p>Then we have the connection object generate a rectangular coordinate system for us to use. A rectangular (Cartesian) system can be used to represent anything that can be plotted using (X,Y) coordinates, such as the location of transistors on a silicon chip. </p>
<pre class="input">    conn.createRectangularSystem(scale=10, xMax=100, yMax=100) 
</pre>
<p>The size of the coordinate system is determined by the <strong>xMin, xMax, yMin</strong> and <strong>yMax</strong> parameters. The minimum values default to zero, so this system is 0 to 100 in the X dimension, and 0 to 100 in the Y dimension. </p>
<p>The <strong>scale</strong> parameter influences how the coordinate data is stored and retrieved, and impacts search performance. The  task is to locate the people who are within a specific region. As a rule of thumb, set the scale parameter to approximately the same value as the height (Y-axis) of your typical search region. You can be off by a factor of ten without impacting performance too badly, but if your application will search regions that are orders of magnitude different in size, you'll want to create multiple coordinate systems that are scaled for different sized search regions. In this case, our search region is about 20 units high (Y), and we have set the scale parameter to 10 units. That's close enough.</p>
<p>The next step is to create a &quot;location&quot; predicate and enter the locations of the three people. </p>
<pre class="input">    location = conn.createURI(exns, &quot;location&quot;)<br>    conn.add(alice, location, conn.createCoordinate(30,30))<br>    conn.add(bob, location, conn.createCoordinate(40, 40))<br>    conn.add(carol, location, conn.createCoordinate(50, 50))  
</pre>
<p>Note that the coordinate pairs need to be encapsulated in a GeoCoordinate object to facilitate indexing and retrieval, using the connection object's <strong>createCoordinate()</strong> method. </p>
<p>At this point we have a Cartesian coordinate system containing three entities at specific (X,Y) locations. The next step is to define a search region. The first example is a &quot;box&quot; that is twenty units square, with the upper left corner at position (20, 20). The <strong>createBox()</strong> method requires parameters for <strong>xMin, xMax, yMin</strong>, and <strong>yMax</strong>. </p>
<pre class="input">    box1 = conn.createBox(20, 40, 20, 40)  
</pre>
<p>The problem is to find the people whose locations lie within this box:</p>
<p><img src="geoBox1.jpg" width="412" height="330"></p>
<p>Locating the matching entities is remarkably easy to do:</p>
<pre class="input">    for r in conn.getStatements(None, location, box1) : print r 
</pre>
<p>This retrieves all the location triples whose coordinates fall within the box1 region. Here are the resulting triples:</p>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+39.999999990686774+39.999999990686774&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;) </pre>
<p>AllegroGraph has located Alice and Bob, as expected. Note that Bob was exactly on the corner of the search area, showing that the boundaries are inclusive. </p>
<p>We can also find all objects within a circle with a known center and radius. Circle1 is centered at (35, 35) and has a radius of 10 units.</p>
<pre class="input">    circle1 = conn.createCircle(35, 35, radius=10)   
</pre>
<p><img src="geoCircle1.jpg" width="415" height="333"></p>
<p>A search within circle1 finds Alice and Bob again:</p>
<pre class="input">    for r in conn.getStatements(None, location, circle1) : print r 
</pre>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+39.999999990686774+39.999999990686774&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;) </pre>
<p>AllegroGraph can also locate points that lie within an irregular polygon. Just tell AllegroGraph the vertices of the polygon:</p>
<pre class="input">    polygon1 = conn.createPolygon([(10,40), (50,10), (35,40), (50,70)]) 
</pre>
<p><img src="geoPolygon1.jpg" width="423" height="330"></p>
<p>When we ask which people are within polygon1, AllegroGraph finds Alice.</p>
<pre class="input">    for r in conn.getStatements(None, location, polygon1) : print r 
</pre>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)</pre>
<h3>Spherical System</h3>
<p>A spherical coordinate system projects (X,Y) locations on a spherical surface, simulating locations on the surface of the earth. AllegroGraph supports the usual units of latitude and longitude in the spherical system. The default unit of distance is the kilometer (km). (These functions presume that the sphere is the size of the planet earth. For spherical coordinate systems of other sizes, you will have to work with the Lisp radian functions that underlie this interface.)</p>
<p><img src="geoWorld.jpg" width="602" height="340"></p>
<p>To establish a global coordinate system, use the connection object's createLatLongSystem() method. </p>
<pre class="input">    latLongGeoType = conn.createLatLongSystem(scale=5, unit='degree')</pre>
<p>Once again, the <strong>scale</strong> parameter is an estimate of the size of a typical search area, in the longitudinal direction this time. The default unit is the degree. For this system, we expect a typical search to cover about five degrees in the east-west direction. Actual search regions may be as much as ten times larger or smaller without significantly impacting performance. If the application will use search regions that are significantly larger or smaller, then you will want to create multiple coordinate systems that have been optimized for different scales. </p>
<p>First we set up the resources for the entities within the spherical system. We'll need these subject URIs:</p>
<pre class="input">    amsterdam = conn.createURI(exns, &quot;amsterdam&quot;)<br>    london = conn.createURI(exns, &quot;london&quot;)<br>    sanfrancisto = conn.createURI(exns, &quot;sanfrancisco&quot;)<br>    salvador = conn.createURI(exns, &quot;salvador&quot;)     
</pre>
<p>Then we'll need a <strong>geolocation</strong> predicate to describe the lat/long coordinates of each entity.</p>
<pre class="input">    location = conn.createURI(exns, &quot;geolocation&quot;)</pre>
<p>Now we can create the entities by asserting a geolocation for each one. Note that the coordinates have to be encapsulated in coordinate objects: </p>
<pre class="input">    conn.add(amsterdam, location, conn.createCoordinate(52.366665, 4.883333))<br>    conn.add(london, location, conn.createCoordinate(51.533333, -0.08333333))<br>    conn.add(sanfrancisto, location, conn.createCoordinate(37.783333, -122.433334)) <br>    conn.add(salvador, location, conn.createCoordinate(13.783333, -88.45))  </pre>
<p>The coordinates are decimal degrees. Northern latitudes and eastern longitudes are positive. </p>
<p>The next step is to create a box-shaped region, so we can see what entities lie within it. </p>
<pre class="input">    box2 = conn.createBox( 25.0, 50.0, -130.0, -70.0) 
</pre>
<p>This region corresponds roughly to the contiguous United States. </p>
<p><img src="geoBox2.jpg" width="634" height="361"></p>
<p>Now we retrieve all the triples located within the search region:</p>
<pre class="input">    for r in conn.getStatements(None, location, box2) : print r     
</pre>
<p>AllegroGraph has located San Francisco:</p>
<pre class="output">(&lt;http://example.org/people/sanfrancisco&gt;, &lt;http://example.org/people/geolocation&gt;,
&quot;+374659.49909-1222600.00212&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/
spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;) 
</pre>
<p>This time let's search for entities within 2000 kilometers of Mexico City, which is located at 19.3994 degrees north latitude, -99.08 degrees west longitude. </p>
<pre class="input">    circle2 = conn.createCircle(19.3994, -99.08, 2000, unit='km')</pre>
<p><img src="geoCircle2.jpg" width="630" height="365"></p>
<pre class="input">    for r in conn.getStatements(None, location, circle2) : print r</pre>
<pre class="output">(&lt;http://example.org/people/salvador&gt;, &lt;http://example.org/people/geolocation&gt;, 
&quot;+134659.49939-0882700&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;)</pre>
<p>And AllegroGraph returns the triple representing El Salvador. </p>
<p>In the next example, the search area is a triangle roughly enclosing the United Kingdom:</p>
<pre class="input">    polygon2 = conn.createPolygon([(51.0, 2.00),(60.0, -5.0),(48.0,-12.5)])
</pre>
<p><em><img src="geoPolygon2.jpg" width="631" height="385"> </em></p>
<p>We ask AllegroGraph to find all entities within this triangle:</p>
<pre class="input">    for r in conn.getStatements(None, location, polygon2) : print r 
</pre>
<pre class="output">(&lt;http://example.org/people/london&gt;, &lt;http://example.org/people/geolocation&gt;, 
&quot;+513159.49909-0000459.99970&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;)</pre>
<p>AllegroGraph returns the location of London, but not the nearby Amsterdam.</p>

<h2 id="Social Network Analysis">Social Network Analysis  (example21())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph includes sophisticated algorithms for social-network analysis (SNA). It can examine an RDF graph of relationships among people (or similar entities, such as businesses) and discover:</p>
<ul>
  <li>Cliques of mutually-supporting individuals.</li>
  <li>The importance of a person within a clique. </li>
  <li>Paths from one individual to another.</li>
  <li>Bottlenecks where information flow might be controlled or break down. </li>
</ul>
<p>This section has multiple subsections:</p>
<ul>
  <li><a href="#Example Network">Example Network</a></li>
  <li><a href="#Setting Up the Example">Setting Up the Example</a></li>
  <li><a href="#Creating SNA Generators">Creating SNA Generators</a></li>
    <li><a href="#Creating Neighbor Matrices">Creating Neighbor Matrices</a></li>
    <li><a href="#Deleting Generators and Matrices">Deleting Generators and Matrices</a></li>
    <li><a href="#SNA Search - Ego Group">SNA Search - Ego Group</a></li>
    <li><a href="#SNA Search - Path from A to B">SNA Search - Path from A to B</a></li>
    <li><a href="#Graph Measures">Graph Measures</a></li>
    <li><a href="#Cliques">Cliques</a></li>
    <li><a href="#Actor Centrality">Actor Centrality</a></li> 
    <li><a href="#Group Centrality">Group Centrality</a></li> 
</ul>
<p>Most (but not all) of AllegroGraph's SNA features can be accessed from Python. We access them in multiple ways:</p>
<ul>
  <li>The Python Sesame API to AllegroGraph contains setup functions that let you create an SNA environment ready for queries.</li>
  <li>From Python, we can issue Prolog queries to AllegroGraph. Some of the SNA functions have Prolog equivalents that can be called directly from a query. These are explored in the sections below. </li>
  <li>Within a Prolog query, we can open a window into Lisp and reach for the AllegroGraph's Lisp SNA functions. </li>
</ul>
<h3 id="Example Network">Example Network</h3>
<p>The example file for this exercise is <strong>python-lesmis.rdf</strong>. It contains resources representing 80 characters from Victor Hugo's <em>Les Miserables</em>, a novel about Jean Valjean's search for redemption in 17th-century Paris. </p>
<p>The raw data behind the model measured the strength of relationships by counting the number of book chapters where two characters were both present. The five-volume novel has 365 chapters, so it was possible to create a relationship network that had some interesting features. This is a partial display of the graph in <a href="http://www.franz.com/agraph/gruff/index.lhtml">Franz's Gruff graphical browser</a>. </p>
<p><img src="lesmismap.jpg" width="768" height="426"> </p>
<p>There are four possible relationships between any two characters. </p>
<ul>
  <li><strong>No direct connection</strong>. (They never appeared in the same chapter.) AllegroGraph can locate indirect connections through their mutual acquaintances.</li>
  <li><span class="style1"><strong>Barely knows</strong></span><strong>.</strong> The characters barely know each other.</li>
  <li><span class="style2"><strong>Knows</strong></span><strong>.</strong> The two characters appear together in 15 or more chapters.</li>
  <li><span class="style3"><strong>Knows well</strong></span><strong>.</strong> The two characters appear together in 25 or more chapters. </li>
</ul>
<p>(The Gruff illustrations were made from a parallel repository in which the resources were altered to display the character's name in the graph node rather than his URI. That file is called<strong> lemisNames.rdf</strong>.) </p>
<h3 id="Setting Up the Example">Setting Up the Example</h3>
<p>The SNA examples are in function <strong>example21() </strong>in <strong>tutorial_examples_40.py</strong>. This exercise begins by creating a <a href="#Transaction Control">dedicated session</a> for the SNA Prolog queries to operation within. These are the same initializing steps we have used in previous examples, plus <strong>conn.openSession()</strong> to create a dedicated connection. </p>
<pre class="input">    server = AllegroGraphServer(AG_HOST, AG_PORT, AG_USER, AG_PASSWORD)<br>    catalog = server.openCatalog(AG_CATALOG)  <br>    myRepository = catalog.getRepository(AG_REPOSITORY, Repository.RENEW)<br>    myRepository.initialize()<br>    conn = myRepository.getConnection()<br>    conn.openSession() # SNA requires dedicated session.</pre>
<p>The next step is to load the python-lesmis.rdf file.</p>
<pre class="input">    path1 = "./python-lesmis.rdf"
    print "Load Les Miserables triples."
    conn.addFile(path1, None, format=RDFFormat.RDFXML);
</pre>

<p>There are three predicates of interest in the Les Miserables repository. We need to create their URIs and bind them for later use. These are the <strong>knows, barely_knows,</strong> and <strong>knows_well</strong> predicates. </p>
<pre class="input">    # Create URIs for relationship predicates.
    lmns = "http://www.franz.com/lesmis#"
    conn.setNamespace('lm', lmns)
    knows = conn.createURI(lmns, "knows")
    barely_knows = conn.createURI(lmns, "barely_knows")
    knows_well = conn.createURI(lmns, "knows_well")
</pre>
<p>We need to bind URIs for two characters: Valjean and Bossuet.  Any analysis of <em>Les Miserables</em> will involve Valjean. Bossuet is someone who &quot;barely knows&quot; Valjean, but the two characters are linked through multiple characters who are more strongly connected. We will ask AllegroGraph to find paths from Valjean to Bossuet.</p>
<pre class="input">    # Create URIs for some characters.
    valjean = conn.createURI(lmns, "character11")
    bossuet = conn.createURI(lmns, "character64")
</pre>

<h3 id="Creating SNA Generators">Creating SNA Generators</h3>
<p>The SNA functions use &quot;generators&quot; to describe the relationships  we want to analyze. A generator encapsulates a list of predicates to use in social network analysis. It also describes the directions in which each predicate is interesting. </p>
<p>In an RDF graph, two resources are linked by a single triple, sometimes called a &quot;resource-valued predicate.&quot; This triple has a resource URI in the <em>subject</em> position, and a different one in the <em>object</em> position. For instance:</p>
<pre>    (&lt;Cosette&gt;, knows_well, &lt;Valjean&gt;)</pre>
<p>This triple  is a one-way link unless we tell the generator to treat it as bidirectional. This is frequently necessary in RDF data, where inverse relations are often implied but not explicitly declared as triples. </p>
<p>For this exercise, we will declare three generators:</p>
<ul>
  <li>&quot;intimates&quot; uses <strong>knows_well</strong> as a bidirectional predicate.</li>
  <li>&quot;associates&quot; uses <strong>knows</strong> and <strong>knows_well</strong> as bidirectional predicates.</li>
  <li>&quot;everyone&quot; uses <strong>barely_knows</strong>, <strong>knows</strong>, and <strong>knows_well</strong> as bidirectional predicates. </li>
</ul>
<p>"Intimates" takes a narrow view of persons who know one another quite well. "Associates" follows both strong and medium relationships. "Everyone" follows all relationships, even the weak ones. This provides three levels of resolution for our analysis.</p>
<p>The connection object's <strong>registerSNAGenerator()</strong> method asks for a generator name (any label), and then for one or more predicates of interest. Each predicate should be assigned to the &quot;subjectOf&quot; direction, the &quot;objectOf&quot; direction, or the &quot;undirected&quot; direction (both ways at once). In addition, you may specify a &quot;generator query,&quot; which is a Prolog &quot;select&quot; query that lets you be more specific about the links you want to analyze. </p>
<p>&quot;Intimates&quot; follows &quot;knows_well&quot; links only, but it treats them as bidirectional. If Cosette knows Valjean, then we'll assume that Valjean knows Cosette. </p>
<pre class=input>    conn.registerSNAGenerator(&quot;intimates&quot;, subjectOf=None, objectOf=None, <br>        undirected=knows_well, generator_query=None)</pre>
<p>&quot;Associates&quot; follows &quot;knows&quot; and &quot;knows_well&quot; links. </p>
<pre class="input">
    conn.registerSNAGenerator(&quot;associates&quot;, subjectOf=None, objectOf=None, <br>        undirected=[knows, knows_well], generator_query=None)
</pre>
<p>&quot;Everyone&quot; follows all three relationship links. </p>
<pre class="input">    conn.registerSNAGenerator(&quot;everyone&quot;, subjectOf=None, objectOf=None, <br>        undirected=[knows, knows_well, barely_knows], 
        generator_query=None)</pre>
<p>&nbsp;</p>		

<h3 id="Creating Neighbor Matrices">Creating Neighbor Matrices</h3>
<p>A generator provides a powerful and flexible tool for examining a graph, but it performs repeated queries against the repository in order to extract the subgraph appropriate to your query. If your data is static, the generator will extract the same subgraph each time you use it. It is better to run the generator once and store the results for quick retrieval. </p>
<p>That is the purpose of  a &quot;neighbor matrix.&quot; This is a persistent, in-memory cache of a generator's output. You can substitute the matrix for the generator in AllegroGraph's SNA functions. </p>
<p>The advantage of using a matrix instead of a generator is a many-fold increase in speed. This benefit is especially visible if you are searching for paths between two nodes in your graph. The exact difference in speed is difficult to estimate because there can be complex trade-offs and scaling issues to consider, but it is easy to try the experiment and observe the effect. </p>
<p>To create a matrix, use the connection object's <strong>registerNeighborMatrix()</strong> method. You must supply a matrix name (any symbol), the name of the generator, the URI of a resource to serve as the starting point, and a maximum depth. The idea is to place limits on the subgraph so that the search algorithms can operate in a restricted space rather than forcing them to analyze the entire repository. </p>
<p>In the following excerpt, we are creating three matrices to match the three generators we created. In this example, &quot;matrix1&quot; is the matrix for generator &quot;intimates,&quot; and so forth. </p>
<pre class="input">    conn.registerNeighborMatrix(&quot;matrix1&quot;, &quot;intimates&quot;, valjean, max_depth=2)<br>    conn.registerNeighborMatrix(&quot;matrix2&quot;, &quot;associates&quot;, valjean, max_depth=2)<br>    conn.registerNeighborMatrix(&quot;matrix3&quot;, &quot;everyone&quot;, valjean, max_depth=2)</pre>
<p>A matrix is a static snapshot of the output of a generator.  If your data is dynamic, you should regenerate the matrix at intervals.</p>

<h3 id="Deleting Generators and Matrices">Deleting Generators and Matrices</h3>
<p>There is no direct way to delete individual matrices and generators, but closing the dedicated session frees all of the resources formerly used by all of the objects and structures that were created there. </p>

<h3 id="SNA Search - Ego Group"><strong>SNA Search - Ego Group</strong></h3>
<p>Our first search will enumerate Valjean's &quot;ego group members.&quot; This is the set of nodes (characters) that can be found by following the interesting predicates out from Valjean's node of the graph to some specified depth. We'll use the &quot;associates&quot; generator (&quot;knows&quot; and &quot;knows_well&quot;) to specify the predicates, and we'll impose a depth limit of one link. This is the group we expect to find:</p>
<p><img src="snaEgoGroup.jpg" width="599" height="203"></p>
<p>The following Python code sends a Prolog query to AllegroGraph and returns the result to Python. </p>
<pre class="input">    print "Valjean's ego group (using associates)."
    queryString = """
    (select (?member ?name)
      (ego-group-member !lm:character11 1 associates ?member)
      (q ?member !dc:title ?name))
      """
    tupleQuery = conn.prepareTupleQuery(QueryLanguage.PROLOG, queryString)
    result = tupleQuery.evaluate();
    print &quot;Found %i query results&quot; % len(result)      <br>    for bindingSet in result:
        p = bindingSet.getValue("member")
        n = bindingSet.getValue("name")
        print "%s %s" % (p, n)
</pre>
<p>This is the iconic block of code that is repeated in the SNA examples, below, with minor variations in the display of bindingSet values. To save virtual trees, we'll focus more tightly on the Prolog query from this point on:</p>
<pre class="input">    (select (?member ?name)
      (ego-group-member !lm:character11 1 associates ?member)
      (q ?member !dc:title ?name))
</pre>
<p>In this example, <strong>ego-group-member</strong> is an AllegroGraph SNA function that has been adapted for use in Prolog queries. There is a list of such functions on the <a href="http://www.franz.com/agraph/support/documentation/current/lisp-reference.html#sna">AllegroGraph documentation reference page</a>. </p>
<p>The query will execute <strong>ego-group-member</strong>, using Valjean (character11) as the starting point, following the predicates described in &quot;associates,&quot; to a depth of 1 link. It binds each matching node to <strong>?member</strong>. Then, for each binding of ?member, the query looks for the member's <strong>dc:title</strong> triple, and binds the member's <strong>?name</strong>.  The query returns multiple results, where each result is a (?member ?name) pair. The result object is passed back to Python, where we can iterate over the results and print out their values. </p>
<p>This is the output of the example:</p>
<pre class="output">Valjean's ego group (using associates).
Found 8 query results
&lt;http://www.franz.com/lesmis#character27&gt; "Javert"
&lt;http://www.franz.com/lesmis#character24&gt; "MmeThenardier"
&lt;http://www.franz.com/lesmis#character25&gt; "Thenardier"
&lt;http://www.franz.com/lesmis#character28&gt; "Fauchelevent"
&lt;http://www.franz.com/lesmis#character11&gt; "Valjean"
&lt;http://www.franz.com/lesmis#character26&gt; "Cosette"
&lt;http://www.franz.com/lesmis#character23&gt; "Fantine"
&lt;http://www.franz.com/lesmis#character55&gt; "Marius"</pre>
<p>If you compare this list with the Gruff-generated image of Valjean's ego group, you'll see that AllegroGraph has found all eight expected nodes. You might be surprised that Valjean is regarded as a member of his <em>own</em> ego group, but that is a logical result of the definition of &quot;ego group.&quot; The ego group is the set of all nodes within a certain depth of the starting point, and certainly the starting point must be is a member of that set. </p>
<p>We can perform the same search using a neighbor matrix, simply by substituting &quot;matrix2&quot; for &quot;associates&quot; in the query:</p>
<pre class="input">    (select (?member ?name)
      (ego-group-member !lm:character11 1 <strong>matrix2</strong> ?member)
      (q ?member !dc:title ?name))
</pre>
<p>This produces the same set of result nodes, but under the right circumstances the matrix would run a lot faster than the generator. </p>
<p>This variation returns Valjean's ego group as a single list. </p>
<pre class="input">    (select (?group)
      (ego-group !lm:character11 1 associates ?group))</pre>
<p>The result in the Python interaction window is:</p>
<pre class="output">Valjean's ego group in one list depth 1 (using associates).<br>Found 1 query results<br>[ &lt;http://www.franz.com/lesmis#character27&gt; &lt;http://www.franz.com/lesmis#character25&gt; <br>&lt;http://www.franz.com/lesmis#character28&gt; &lt;http://www.franz.com/lesmis#character23&gt; <br>&lt;http://www.franz.com/lesmis#character26&gt; &lt;http://www.franz.com/lesmis#character55&gt; <br>&lt;http://www.franz.com/lesmis#character11&gt; &lt;http://www.franz.com/lesmis#character24&gt; ]</pre>

<h3 id="SNA Search - Path from A to B">SNA Search - Path from A to B</h3>
<p>In the following examples, we explore the graph for the shortest path from Valjean to Bossuet, using the three generators to place restrictions on the quality of the path. These are the relevant paths between these two characters:</p>
<img src="pathsValBos.jpg" width="913" height="254"> 
<p>Our first query asks AllegroGraph to use <strong>intimates</strong> to find the shortest possible path between Valjean and Bossuet that is composed entirely of &quot;knows_well&quot; links. Those would be the green arrows in the diagram above. The <strong>breadth-first-search-path</strong> function asks for a start node and an end node, a generator, an optional maximum path length, and a variable to bind to the resulting path(s). Valjean is character11, and Bossuet is character64.</p>
<pre class="input">    (select (?path)
      (breadth-first-search-path !lm:character11 !lm:character64 intimates 10 ?path))</pre>
<p>It is easy to examine the diagram and see that there is no such path. Valjean and Bossuet are not well-acquainted, and do not have any chain of well-acquainted mutual friends. AllegroGraph lets us know that.</p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using intimates.
Found 1 query results
[ ]</pre>
<p>It says there is one result, but that is actually the empty list. </p>
<p>This time we'll broaden the criteria. What is the shortest path from Valjean to Bossuet, using <strong>associates</strong>? We can follow either &quot;knows_well&quot; or &quot;knows&quot; links across the graph. Those are the green and the blue links in the diagram. </p>
<pre class="input">(select (?path)
      (breadth-first-search-path !lm:character11 !lm:character64 associates 10 ?path))</pre>
<p>Although there are multiple such paths, there are only two that are &quot;shortest&quot; paths. </p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using associates.<br>Found 2 query results<br>[ &lt;http://www.franz.com/lesmis#character11&gt; &lt;http://www.franz.com/lesmis#character55&gt;<br> &lt;http://www.franz.com/lesmis#character58&gt; &lt;http://www.franz.com/lesmis#character64&gt; ]<br>[ &lt;http://www.franz.com/lesmis#character11&gt; &lt;http://www.franz.com/lesmis#character55&gt;<br> &lt;http://www.franz.com/lesmis#character62&gt; &lt;http://www.franz.com/lesmis#character64&gt; ]</pre>
<p>These are the paths &quot;Valjean &gt; Marius &gt; Enjolras &gt; Bossuet&quot; and &quot;Valjean &gt; Marius &gt; Courfeyrac &gt; Bossuet.&quot; AllegroGraph returns two paths because they are of equal length. If one of the paths had been shorter, it would have returned only the short path. </p>
<p>Our third query asks for the shortest path from Valjean to Bossuet using <strong>everyone</strong>, which means that &quot;barely-knows&quot; links are permitted in addition to &quot;knows&quot; and &quot;knows_well&quot; links. </p>
<pre class="input">    (select (?path)
      (breadth-first-search-path !lm:character11 !lm:character64 everyone 10 ?path))
</pre>
<p>This time AllegroGraph returns a single, short path:</p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using everyone.<br>Found 1 query results<br>[ &lt;http://www.franz.com/lesmis#character11&gt; &lt;http://www.franz.com/lesmis#character64&gt; ]</pre>
<p>This is the &quot;barely-knows&quot; link directly from from Valjean to Bossuet. </p>
<p>The Prolog select query can also use <strong>depth-first-search-path()</strong> and <strong>bidirectional-search-path()</strong>. Their syntax is essentially identical to that shown above. These algorithms offer different efficiencies:</p>
<ul>
  <li>Breadth-first and bidirectional searches explore all paths by incrementing the search radius until a success is achieved. This guarantees that the returned path(s) will be &quot;shortest&quot; paths. They return one or more paths of equal lengths. </li>
  <li>Depth-first search tries to bypass the costly expansion of all paths by exploring each path to its end, and aborting the search when it locates a successful path. There is no implication that this path is the &quot;shortest&quot; path through the graph. </li>
</ul>
<p>In addition, the depth-first algorithm uses less memory than the others, so a depth-first search may succeed when a breadth-first search would run out of memory. </p>

<h3 id="Graph Measures">Graph Measures</h3>
<p>AllegroGraph provides several utility functions that measure the characteristics of a node, such as the number of connections it has to other nodes, and its importance as a communication path in a clique. </p>
<p>For instance, we can use the <strong>nodal-degree</strong> function to ask how many nodal neighbors Valjean has, using <strong>everyone</strong> to catalog all the nodes connected to Valjean by &quot;knows,&quot; &quot;barely_knows&quot;, and &quot;knows_well&quot; predicates. There are quite a few of them:</p>
<p><img src="allLinksValjean.jpg" width="720" height="341"> </p>
<p>The nodal-degree function requires the URI of the target node (Valjean is character11), the generator, and a variable to bind the returned value to. </p>
<pre class="input">    print &quot;\nHow many neighbors are around Valjean? (should be 36).&quot;<br>    queryString = &quot;&quot;&quot;<br>    (select ?neighbors<br>      (nodal-degree !lm:character11 everyone ?neighbors))<br>      &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.PROLOG, queryString)<br>    result = tupleQuery.evaluate();<br>    for bindingSet in result:<br>        p = bindingSet.getValue(&quot;neighbors&quot;)<br>        print &quot;%s&quot; % (p)<br>        print &quot;%s&quot; % <strong>p.toPython()</strong></pre>
<p>Note that this function returns a string that describes an integer, which in its raw form is difficult for Python to use. We convert the raw value to a Python integer using the <strong>.toPython() </strong>method that is available to all literal values in the Python Sesame API to AllegroGraph. This example prints out both the string value and the converted number.</p>
<pre class="output">How many neighbors are around Valjean? (should be 36).
"36"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;
36</pre>
<p>If you want to see the names of these neighbors, you can use either the <strong>ego-group-member</strong> function described earlier on this page, or the <strong>nodal-neighbors</strong> function shown below:</p>
<pre class="input">    print &quot;\nWho are Valjean's neighbors? (using everyone).&quot;<br>    queryString = &quot;&quot;&quot;<br>    (select (?name)<br>      (nodal-neighbors !lm:character11 everyone ?member)<br>      (q ?member !dc:title ?name))<br>      &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.PROLOG, queryString)<br>    result = tupleQuery.evaluate();<br>    count = 0<br>    for bindingSet in result:<br>        count = count + 1<br>        n = bindingSet.getValue(&quot;name&quot;)<br>        print &quot;%s. %s &quot; % (count,n.toPython())</pre>
<p>This example enumerates all immediate neighbors of Valjean and returns their names. This example prints a numbered list with 36 entries:
<pre class="output">Who are Valjean's neighbors? (using everyone).<br>1. Isabeau <br>2. Fantine <br>3. Labarre <br>4. Bossuet <br>5. Brevet ...</pre>

<p>Another descriptive statistic is <strong>graph-density</strong>, which measures the density of connections within a subgraph. </p>
<p>For instance, this is Valjean's ego group with all <strong>associates</strong>  included. </p>
<p><img src="graphDensity.jpg" width="806" height="297"> </p>
<p>Only 9 of 28 possible links are in place in this subgraph, so the graph density is 0.32. The following query asks AllegroGraph to calculate this figure for Valjean's ego group:</p>
<pre class="input">
    (select ?density
      (ego-group !lm:character11 1 associates ?group)
      (graph-density ?group associates ?density))
</pre>
<p>We used the<strong> ego-group</strong> function to return a list of Valjean's ego-group members, bound to the variable <strong>?group</strong>, and then we used ?group to feed that subgraph to the <strong>graph-density</strong> function. The return value, <strong>?density</strong>, came back as a string describing a float, and had to be converted to a Python float using <strong>.toPython()</strong>.</p>
<pre class="output">Graph density of Valjean's ego group? (using associates).
"3.2142857e-1"^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;
3.2142857e-1</pre>
<h3 id="Cliques">Cliques</h3>
<p>A &quot;clique&quot; is a subgraph where every node is connected to every other node by predicates specified in some generator. AllegroGraph, using everyone (&quot;knows,&quot; &quot;knows_well,&quot; and &quot;barely_knows&quot;), found that Valjean participates in 239 cliques! </p>
<p><img src="valjeanBigClique.jpg" width="859" height="301"> </p>
<p>It is counterintuitive that a &quot;clique&quot; should be composed mainly of people who &quot;barely_know&quot; each other, so let's try the same experiment using &quot;associates,&quot; which restricts the cliques to people Valjean &quot;knows&quot; or &quot;knows_well.&quot; In this case, AllegroGraph returns two cliques. One contains Valjean, Cosette, and Marius. The other contains Valjean and the Thenardiers. </p>
<p><img src="valjeanSmallCliques.jpg" width="397" height="248"> </p>
<p>This is the query that finds Valjean's &quot;associates&quot; cliques:</p>
<pre class="input">
    (select (?clique)
      (clique !lm:character11 associates ?clique))
</pre>



<p>AllegroGraph returns two cliques:</p>
<pre class="output">Valjean's cliques? Should be two (using associates).<br>[ &lt;http://www.franz.com/lesmis#character11&gt; &lt;http://www.franz.com/lesmis#character25&gt;<br> &lt;http://www.franz.com/lesmis#character24&gt; ]<br>[ &lt;http://www.franz.com/lesmis#character11&gt; &lt;http://www.franz.com/lesmis#character55&gt;<br> &lt;http://www.franz.com/lesmis#character26&gt; ]</pre>
<p>The first list is the clique with Marius and Cosette. The second one represents the Thernardier clique. </p>
<h3 id="Actor Centrality">Actor Centrality </h3>
<p>AllegroGraph lets us measure the relative importance of a node in a subgraph using the <strong>actor-degree-centrality()</strong> function. For instance, it should be obvious that Valjean is very &quot;central&quot; to his own ego group (depth of one link), because he is linked directly to all other links in the subgraph. In that case he is linked to 7 of 7 possible nodes, and his actor-degree-centrality value is 7/7 = 1. </p>
<p>However, we can regenerate Valjean's ego group using a depth of 2. This adds three nodes that are not directly connected to Valjean. How &quot;central&quot; is he then?</p>
<p><img src="valjeanActorCentrality.jpg" width="875" height="303"> </p>
<p>In this subgraph, Valjean's actor-degree-centrality is 0.70, meaning that he is connected to 70% of the nodes in the subgraph. </p>
<p>This example asks AllegroGraph to generate the expanded ego group, and then to measure Valjean's actor-degree-centrality:</p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-degree-centrality !lm:character11 ?group associates ?centrality))
</pre>
<p>Note that we asked <strong>ego-group()</strong> to explore to a depth of two links, and then fed its result (<strong>?group</strong>) to <strong>actor-degree-centrality()</strong>. This is the output:</p>
<pre class="output">Valjean's centrality to his ego group at depth 2 (using associates).
"7.0e-1"^^<http://www.w3.org/2001/XMLSchema#double>
0.7</pre>
<p>This confirms our expectation that Valjean's actor-degree-centrality should be 0.70 in this circumstance.</p>
<p>We can also measure actor centrality by calculating the average path length from a given node to the other nodes of the subgraph. This is called <strong>actor-closeness-centrality</strong>. For instance, we can calculate the average path length from Valjean to the ten nodes of his ego group (using associates and depth 2). Then we take the inverse of the average, so that bigger values will be &quot;more central.&quot; </p>
<p><img src="valjeanActorClosenessCentrality.jpg" width="875" height="303"> </p>
<p>The actor-closeness-centrality for Valjean is 0.769. For Marius it is 0.60, showing that Valjean is more central and important to the group than is Marius. </p>
<p>This example calculates Valjean's <strong>actor-closeness-centrality</strong> for the associates ego group of depth 2. </p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-closeness-centrality !lm:character11 ?group associates ?centrality))
</pre>
<pre class="output">Valjean's actor-closeness-centrality to his ego group at depth 2 (using associates).
"7.692308e-1"^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;
0.7692308</pre>
<p>That is the expected value of 0.769. </p>
<p>Another approach to centrality is to count the number of information paths that are &quot;controlled&quot; by a specific node. This is called<strong> actor-betweenness-centrality</strong>. For instance, there are 45 possible &quot;shortest paths&quot; between pairs of nodes in Valjean's associates depth-2 ego group. Valjean can act as an information valve, potentially cutting off communication on 34 of these 45 paths. Therefore, he controls 75% of the communication in the group. </p>
<p><img src="valjeanActorBetweenCentrality.jpg" width="875" height="303"></p>
<p>This example calculates Valjean's actor-betweenness-centrality:</p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-betweenness-centrality !lm:character11 ?group associates ?centrality))
</pre>

<pre class="output">Valjean's actor-betweenness-centrality to his ego group at depth 2 (using associates).
"7.5555557e-1"^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;
7.5555557</pre>
<p>That's the expected result of 0.755. </p>
<h3 id="Group Centrality">Group Centrality</h3>
<p>Group-centrality measures express the &quot;cohesiveness&quot; of a group. There are three group-centrality measures in AllegroGraph: <strong>group-degree-centrality()</strong>, <strong>group-closeness-centrality()</strong>, and <strong>group-betweenness-centrality()</strong>.</p>
<p>To demonstrate these measures, we'll use Valjean's ego group, first at radius 1 and then at radius 2. As you recall, the smaller ego group is radially symmetrical, but the larger one is quite lop-sided. That makes the smaller group &quot;more cohesive&quot; than the larger one.</p>
<p> <strong>Group-degree-centrality()</strong> measures 
group cohesion by finding the maximum actor centrality in the group, 
summing the difference between this and each other actor's degree 
centrality, and then normalizing. It ranges from 0 (when all actors have 
equal degree) to 1 (when one actor is connected to every other and no 
other actors have connections.</p>
<p>The prolog query takes this form:</p>
<pre class="input"> (select (?centrality)
   (ego-group !lm:character11 1 associates ?group)
   (group-degree-centrality ?group associates ?centrality))</pre>
<p>The query first generates Valjean's (character11) ego group at radius 1, and binds that list of characters to ?group. Then it calls group-degree-centrality() on the group and returns the answer as ?centrality. </p>
<p>The group-degree-centrality for Valjean's radius-1 ego group is 0.129. When we expand to radius 2, the group-degree-centrality drops to 0.056. The larger group is less cohesive than the smaller one. </p>
<p>The following examples were all generated from queries that strongly resemble the one above. </p>
<p> <strong>Group-closeness-centrality()</strong> is 
measured by first finding the actor whose `closeness-centrality` <br>
is maximized and then summing the difference between this maximum 
value and the actor-closeness-centrality of all other actors. 
This value is then normalized so that it ranges between 0 and 1. </p>
<p>The group-closeness-centrality of Valjean's smaller ego group is 0.073. The expanded ego group has a group-closeness-centrality of 0.032. Again, the smaller group is more cohesive.</p>
<p> <strong>Group-betweenness-centrality()</strong> is 
measured by first finding the actor whose actor-betweenness-centrality<br>
is maximized and then summing the difference between this maximum 
value and the actor-betweenness-centrality of all other actors. 
This value is then normalized so that it ranges between 0 and 1.  </p>
<p>Valjean's smaller ego group has a group-betweenness-centrality of 0.904. The value for the larger ego group is 0.704. Even by this measure, the larger group is less cohesive. </p>
<h2 id="Transaction Control">Transaction Control (example22())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>Most of the time, multiple AllegroGraph users pool triples in a common session. Their data may be segregated into multiple contexts (subgraphs) for convenience, but in fact any part of this data may be retrieved by any of the users.</p>
<p>There are situations where a little more security is required. You may open a &quot;dedicated session&quot; and populate it with triples that the other users cannot view. These triples may be searched and manipulated in the usual ways, but do not become visible to other users until you &quot;commit&quot; them to the common session. </p>
<p>In order to use transaction semantics, the user account must have &quot;start sessions&quot; privileges with AllegroGraph Server. This is an elevated level of privilege. AllegroGraph users are profiled through the <a href="#Creating Users with WebView">WebView interface.</a></p>
<p>To experiment with transaction semantics in AllegroGraph, we will need two connections to the triple store. In the &quot;transaction connection&quot; we will load, rollback, reload and commit incoming triples.&nbsp; In the "autocommit connection" we will run queries against the resulting triple store, where the resources are always in a known and complete state. </p>
<p>In practice, transactions require only one connection.&nbsp; We create a special connection for transaction behavior, use it, and close it. </p>
<p>&quot;Commit&quot; means to make the triples in the dedicated session visible in the common session. At the time of the commit, triples in the common session are also made visible to queries in the dedicated session. The two sessions are &quot;synched up&quot; by the commit. </p>
<p>&quot;Rollback&quot; means to discard the contents of the dedicated session. It also makes all common-session triples visible in the dedicated session. </p>
<p>&quot;Closing&quot; the dedicated session deletes all uncommitted triples, and all rules, generators and matrices that were created in the dedicated session. Rules, generators and matrices cannot be committed. They persist as long as the dedicated session persists, and are deleted when the dedicated session is closed.</p>
<p>Example example22() performs some simple data manipulations on a dedicated session to demonstrate the rollback and commit features. It begins by creating a connection to a repository (the common session), and a second connection to a dedicated session. To do that, all you need is a second connection object, and invoke its <strong>openSession()</strong> method. </p>
<pre class="input">    server = AllegroGraphServer(AG_HOST, AG_PORT, 'test', 'xyzzy')<br>    catalog = server.openCatalog('scratch')  <br>    myRepository = catalog.getRepository(AG_REPOSITORY, Repository.RENEW)<br>    myRepository.initialize()<br>    common = myRepository.getConnection()<br>    dedicated = myRepository.getConnection()<br>    dedicated.openSession()  # open dedicated session </pre>
<p>We'll reuse the Kennedy and Les Miserables data. The Les Miserables data goes in the common session, and the Kennedy data goes in the dedicated session. </p>
<pre class="input">    path1 = &quot;./python-kennedy.ntriples&quot;<br>    path2 = &quot;./python-lesmis.rdf&quot;                <br>    baseURI = &quot;http://example.org/example/local&quot;<br>    ## read kennedy triples into the dedicated session:<br>    print &quot;Load 1214 python-kennedy.ntriples into dedicated session.&quot;<br>    dedicated.add(path1, base=baseURI, format=RDFFormat.NTRIPLES, contexts=None)<br>    ## read lesmis triples into the common session:<br>    print &quot;Load 916 lesmis triples into the common session.&quot;<br>    common.addFile(path2, baseURI, format=RDFFormat.RDFXML, context=None);</pre>
<p>The two sessions should now have independent content. When we look in the common session we should see only Les Miserables triples. The dedicated session could contain only Kennedy triples. We set up a series of simple tests similar to this one:</p>
<pre class="input">    print &quot;\nUsing getStatements() on common session; should find Valjean:&quot;
    Valjean = common.createLiteral(&quot;Valjean&quot;)
    statements = common.getStatements(None, None, Valjean, 'null', limit=1)
    print &quot;Number of results: %s&quot; % len(statements)
    for s in statements:
    print s
</pre>
<p>This test looks for our friend Valjean in the common session. He should be there. This is the output:</p>
<pre class="output">Using getStatements() on common session; should find Valjean:
   Number of results: 1
   (&lt;http://www.franz.com/lesmis#character11&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;Valjean&quot;)
</pre>
<p>However, there should not be anyone in the common session named &quot;Kennedy.&quot; The code of the test is almost identical to that shown above, so we'll skip straight to the output.</p>
<pre class="output">Using getStatements() on common session; should not find Kennedy:
   Number of results: 0</pre>
<p>There should be a Kennedy (at least one) visible in the dedicated session:</p>
<pre class="output">Using getStatements() on dedicated session; should find Kennedys:
   Number of results: 1
 (&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#last-name&gt;, &quot;Kennedy&quot;) </pre>
<p>And finally, we should not see Valjean in the dedicated session:</p>
<pre class="output">Using getStatements() on dedicated session; should not find Valjean:
   Number of results: 0  </pre>
<p>The next step in the demonstration is to roll back the data in the dedicated session. This will make the Kennedy data disappear. It will also make the Les Miserables data visible in both sessions. We'll perform the same four tests, with slightly different expectations.</p>
<p>First we roll back the transaction:</p>
<pre class="input">    dedicated.rollback() </pre>
<p>Valjean is still visible in the common session:</p>
<pre class="output">Using getStatements() on common session; should find Valjean:
   Number of results: 1
   (&lt;http://www.franz.com/lesmis#character11&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;Valjean&quot;)
</pre>
<p>There are still no Kennedys in the common session: </p>
<pre class="output">Using getStatements() on common session; should find Kennedys:<br>Number of results: 0</pre>
<p>There should be no Kennedys visible in the dedicated session:</p>
<pre class="output">Using getStatements() on dedicated session; should find Kennedys:
   Number of results: 0
</pre>
<p>And finally, we should suddenly see Valjean in the dedicated session:</p>
<pre class="output">Using getStatements() on dedicated session; should not find Valjean:
   Number of results: 1
   (&lt;http://www.franz.com/lesmis#character11&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;Valjean&quot;)</pre>
<p>The rollback has succeeded in deleting the uncommitted triples from the dedicated session. It has also refreshed or resynched the dedicated session with the common session.</p>
<p>To set up the next test, we have to reload the Kennedy triples. Then we'll perform a commit.  </p>
<pre class="input">    print &quot;\nReload 1214 python-kennedy.ntriples into dedicated session.&quot;<br>    dedicated.add(path1, base=baseURI, format=RDFFormat.NTRIPLES, contexts=None)<br>    dedicated.commit()</pre>
<p>This should make both types of triples visible in both sessions. Here are the four tests:</p>
<pre class="output">Using getStatements() on common session; should find Valjean:
   Number of results: 1
 (&lt;http://www.franz.com/lesmis#character11&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;Valjean&quot;)</pre>
<pre class="output">Using getStatements() on common session; should find Kennedys:
   Number of results: 1
   (&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#last-name&gt;, &quot;Kennedy&quot;)</pre>
<pre class="output">Using getStatements() on dedicated session; should find Kennedys:
   Number of results: 1
   (&lt;http://www.franz.com/simple#person1&gt;, &lt;http://www.franz.com/simple#last-name&gt;, &quot;Kennedy&quot;)</pre>
<pre class="output">Using getStatements() on dedicated session; should find Valjean:
   Number of results: 1
   (&lt;http://www.franz.com/lesmis#character11&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;Valjean&quot;)</pre>
<p>The Les Miserables triples are visible in both sessions. So too are the Kennedy triples. </p>
<p>Remember that when you are done with a session or connection, it is appropriate to close it:</p>
<pre class="input">    dedicated.closeSession()<br>    dedicated.close()<br>    common.close()</pre>
<p>This recovers resources that would otherwise remain bound. </p>
<h2 id="Duplicate Triples">Duplicate Triples (example23()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>Most people find it annoying when a query returns multiple copies of the same information. This can happen in mulitple ways, and there are multiple strategies for reducing or eliminating the problem. There are two broad strategies to pursue:</p>
<ul>
  <li>Don't create duplicate triples. It is surprisingly easy to fill the triple store with duplicates if you are not careful to generate clean RDF files.</li>
  <li>Filter the duplicate results from the output of your queries. SPARQL in particular has features that reduce or eliminate duplicate results. </li>
</ul>
<h3>Tighten Up Your Queries</h3>
<p>Triple patterns sometimes act in unexpected ways, resulting in &quot;too many&quot; matches.</p>
<p><strong>Example23()</strong> revives the Kennedy family tree. It loads the <strong>python-kennedy.ntriples</strong> file, resulting in 1214 triples.</p>
<p>This example focuses on the three children of Ted Kennedy (person17). A simple <strong>getStatements() </strong>query shows us that all three are, in fact, present. They are person72, person74, and person76. </p>
<pre class="output">Using getStatements() find children of Ted Kennedy: three children.<br>Number of results: 3<br>(&lt;http://www.franz.com/simple#person17&gt;, &lt;http://www.franz.com/simple#has-child&gt;, &lt;http://www.franz.com/simple#person72&gt;)<br>(&lt;http://www.franz.com/simple#person17&gt;, &lt;http://www.franz.com/simple#has-child&gt;, &lt;http://www.franz.com/simple#person74&gt;)<br>(&lt;http://www.franz.com/simple#person17&gt;, &lt;http://www.franz.com/simple#has-child&gt;, &lt;http://www.franz.com/simple#person76&gt;) </pre>
<p>Let's imagine that for some bureaucratic or legal reason we need to retrieve any two of the senator's three children from the triple store. We might begin with a SPARQL query like this one:</p>
<pre class="input">    SELECT ?o1 ?o2 <br>       WHERE {kdy:person17 kdy:has-child ?o1 .<br>              kdy:person17 kdy:has-child ?o2 .} </pre>
<p>Since there are only three ways to retrieve a pair from a pool of three, we might be startled to get nine answers:</p>
<pre class="output">SPARQL matches for two children of Ted Kennedy, inept pattern.<br>&lt;http://www.franz.com/simple#person72&gt; and &lt;http://www.franz.com/simple#person72&gt;<br>&lt;http://www.franz.com/simple#person72&gt; and &lt;http://www.franz.com/simple#person74&gt;<br>&lt;http://www.franz.com/simple#person72&gt; and &lt;http://www.franz.com/simple#person76&gt;<br>&lt;http://www.franz.com/simple#person74&gt; and &lt;http://www.franz.com/simple#person72&gt;<br>&lt;http://www.franz.com/simple#person74&gt; and &lt;http://www.franz.com/simple#person74&gt;<br>&lt;http://www.franz.com/simple#person74&gt; and &lt;http://www.franz.com/simple#person76&gt;<br>&lt;http://www.franz.com/simple#person76&gt; and &lt;http://www.franz.com/simple#person72&gt;<br>&lt;http://www.franz.com/simple#person76&gt; and &lt;http://www.franz.com/simple#person74&gt;<br>&lt;http://www.franz.com/simple#person76&gt; and &lt;http://www.franz.com/simple#person76&gt; </pre>
<p>Three of these matches involve the same triple matching both patterns, claiming that each person is a sibling of himself. The other six are permutations of the correct answers, in which we first discover that person72 is a sibling of person74, and then subsequently discover that person74 is a sibling of person72. We didn't need to receive that information twice. </p>
<p>Let's eliminate the useless duplications with a simple trick. Here it is in SPARQL: </p>
<pre class="input">    SELECT ?o1 ?o2 <br>       WHERE {kdy:person17 kdy:has-child ?o1 .<br>              kdy:person17 kdy:has-child ?o2 .<br>              filter (?o1 &lt; ?o2)} </pre>
<p>And this is the equivalent query in Prolog. Note that <strong>lispp</strong> is correct, not a typo:</p>
<pre class="input">    (select (?o1 ?o2)<br>            (q !kdy:person17 !kdy:has-child ?o1)<br>            (q !kdy:person17 !kdy:has-child ?o2) <br>			(lispp (upi&lt; ?o1 ?o2)))</pre>
<p>The inequality insures that the two object variables cannot be bound to the same value, eliminating the sibling-of-self issue, and also that only one of the persons can be bound to ?o1, which eliminates the duplication issue. Now we have the expected three results:</p>
<pre class="output">SPARQL matches for two children of Ted Kennedy, better pattern.<br>&lt;http://www.franz.com/simple#person72&gt; and &lt;http://www.franz.com/simple#person74&gt;<br>&lt;http://www.franz.com/simple#person72&gt; and &lt;http://www.franz.com/simple#person76&gt;<br>&lt;http://www.franz.com/simple#person74&gt; and &lt;http://www.franz.com/simple#person76&gt;
</pre>
<p>Our task, however, is to pluck &quot;any two&quot; of the children from the triple store and then stop. That's easy in SPARQL:</p>
<pre class="input">    SELECT ?o1 ?o2 <br>       WHERE {kdy:person17 kdy:has-child ?o1 .<br>              kdy:person17 kdy:has-child ?o2 .<br>              filter (?o1 &lt; ?o2)}<br>              LIMIT 1 </pre>
<p>This query returns one result that is guaranteed to reference two different children. </p>
<p>The moral of this example is that triple patterns often return more information than you expected, and need to be rewritten to make them less exuberant. You may be able to reduce the incidence of duplicate results simply by writing better queries. </p>
<h3>Tighten Up Your RDF</h3>
<p>The Resource Description Framework (RDF) has many fine qualities, but there are also a few RDF features that create headaches for users. One of these is the ability to encode resources as &quot;blank nodes.&quot; This is a convenience to the person who is generating the data, but it often creates problems for the data consumer.</p>
<p>Here's a simple example. These two RDF resource descriptions represent two books by the same author. The author is described using a &quot;blank node&quot; within the book resource description:</p>
<pre class="input">  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book1&quot;&gt;<br>    &lt;dc:title&gt;The Call of the Wild&lt;/dc:title&gt;<br>    <strong>&lt;dc:creator&gt;<br>	   &lt;foaf:Person foaf:name=&quot;Jack London&quot;/&gt; <br>    &lt;/dc:creator&gt;</strong><br>  &lt;/rdf:Description&gt;<br>  <br>  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book2&quot;&gt;<br>    &lt;dc:title&gt;White Fang&lt;/dc:title&gt;<br>    <strong>&lt;dc:creator&gt;<br>	   &lt;foaf:Person foaf:name=&quot;Jack London&quot;/&gt; <br>    &lt;/dc:creator&gt;</strong><br>  &lt;/rdf:Description&gt; </pre>
<p>This is a common RDF format used by programs that transcribe databases into RDF. In this format, there is no resource URI designated for the foaf:Person resource. Therefore, the RDF parser will generate a URI to use as the subject value of the new resource. The problem is that it generates a new URI each time it encounters an embedded resource. We wind up with eight triples and two different &quot;Jack London&quot; resources:</p>
<pre class="output">Two books, with one author as blank node in each book.<br>Number of results: 8<br><br>(&lt;http://www.franz.com/tutorial#book1&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;The Call of the Wild&quot;)<br>(&lt;http://www.franz.com/tutorial#book1&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, _:bE26D2A88x1)<br><br>(&lt;http://www.franz.com/tutorial#book2&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;White Fang&quot;)<br>(&lt;http://www.franz.com/tutorial#book2&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, _:bE26D2A88x2)<br><br>(_:bE26D2A88x1, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://xmlns.com/foaf/0.1/Person&gt;)<br>(_:bE26D2A88x1, &lt;http://xmlns.com/foaf/0.1/name&gt;, &quot;Jack London&quot;)<br><br>(_:bE26D2A88x2, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://xmlns.com/foaf/0.1/Person&gt;)<br>(_:bE26D2A88x2, &lt;http://xmlns.com/foaf/0.1/name&gt;, &quot;Jack London&quot;) </pre>
<p>You can see the two books, each with a title and a creator. Then there are two &quot;anonymous&quot; resources with generated subject URIs, both of which represent the same author. This is very undesirable. </p>
<p>Duplicate <em>resources</em> are difficult to remove or fix. They have different subject values, which mean their triples are technically not duplicates of each other. The author resources are directly linked to book resources, one-to-one, meaning that you can't just delete the extra authors. That would leave book resources linked to authors that don't exist anymore. </p>
<p>Clearly we don't want to be in this situation. We have to back out and generate the RDF a different way. </p>
<p>We might decide to fix this problem by rewriting the resource descriptions. This time we'll be sure that the formerly anonymous nodes are set up with URIs. This way we'll get only one author resource. This format is what RDF calls &quot;striped syntax.&quot;</p>
<pre class="input">  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book1&quot;&gt;<br>    &lt;dc:title&gt;The Call of the Wild&lt;/dc:title&gt;<br>    &lt;dc:creator&gt;<br>	   <strong>&lt;foaf:Person rdf:about=&quot;#Jack&quot;&gt;<br>	      &lt;foaf:name&gt;Jack London&lt;/foaf:name&gt; <br>	   &lt;/foaf:Person&gt;</strong><br>	&lt;/dc:creator&gt;<br>  &lt;/rdf:Description&gt;<br>  <br>  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book2&quot;&gt;<br>    &lt;dc:title&gt;White Fang&lt;/dc:title&gt;<br>    &lt;dc:creator&gt;<br>	   <strong>&lt;foaf:Person rdf:about=&quot;#Jack&quot;&gt;<br>	      &lt;foaf:name&gt;Jack London&lt;/foaf:name&gt; <br>	   &lt;/foaf:Person&gt;</strong><br>	&lt;/dc:creator&gt;<br>  &lt;/rdf:Description&gt;</pre>
<p>Even though we have embedded two resource descriptions, we gave them both the same URI (&quot;#Jack&quot;). Did this solve the problem? We now have only one &quot;Jack London&quot; resource, but we still have eight triples! </p>
<pre class="output">Two books, with one author identified by URI but in striped syntax in each book.<br>Number of results: 8<br><br>(&lt;http://www.franz.com/tutorial#book1&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;The Call of the Wild&quot;)<br>(&lt;http://www.franz.com/tutorial#book1&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, &lt;http://www.franz.com/simple#Jack&gt;)<br>(&lt;http://www.franz.com/tutorial#book2&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;White Fang&quot;)<br>(&lt;http://www.franz.com/tutorial#book2&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, &lt;http://www.franz.com/simple#Jack&gt;)<br><br>(&lt;http://www.franz.com/simple#Jack&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://xmlns.com/foaf/0.1/Person&gt;)
(&lt;http://www.franz.com/simple#Jack&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://xmlns.com/foaf/0.1/Person&gt;)<br>(&lt;http://www.franz.com/simple#Jack&gt;, &lt;http://xmlns.com/foaf/0.1/name&gt;, &quot;Jack London&quot;)<br>(&lt;http://www.franz.com/simple#Jack&gt;, &lt;http://xmlns.com/foaf/0.1/name&gt;, &quot;Jack London&quot;)</pre>
<p>We have only one &quot;Jack London&quot; author resource, which means we will have a more useful graph than before, but <em>every triple in that resource is duplicated</em>. If we had cataloged fifty books by Jack London, there would be fifty copies of each of these triples. The &quot;striped syntax&quot; generates floods of duplicate triples. </p>
<p>It is much better to avoid blank nodes and striped syntax altogether. Here are the same two books, using a separate author resource that is linked to the books by a URI:</p>
<pre class="input">  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book5&quot;&gt;<br>    &lt;dc:title&gt;The Call of the Wild&lt;/dc:title&gt;<br>    <strong>&lt;dc:creator rdf:resource=&quot;http://www.franz.com/tutorial#author1&quot;/&gt;</strong><br>  &lt;/rdf:Description&gt;<br>  <br>  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book6&quot;&gt;<br>    &lt;dc:title&gt;White Fang&lt;/dc:title&gt;<br>    <strong>&lt;dc:creator rdf:resource=&quot;http://www.franz.com/tutorial#author1&quot;/&gt;</strong><br>  &lt;/rdf:Description&gt;<br>  <br>  &lt;rdf:Description <strong>rdf:about=&quot;http://www.franz.com/tutorial#author1&quot;</strong>&gt;<br>    &lt;dc:title&gt;Jack London&lt;/dc:title&gt;<br>  &lt;/rdf:Description&gt; </pre>
<p>This is arguably the &quot;best&quot; syntax to follow because one author resource is directly connected to all of that author's books. The graph is rich in nodes and connections, while avoiding duplicate triples. This example creates six triples, none of which are duplicates:</p>
<pre class="output">Two books, with one author linked by a URI.<br>Number of results: 6<br><br>(&lt;http://www.franz.com/tutorial#book5&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;The Call of the Wild&quot;)<br>(&lt;http://www.franz.com/tutorial#book5&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, &lt;http://www.franz.com/tutorial#author1&gt;)<br>(&lt;http://www.franz.com/tutorial#book6&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;White Fang&quot;)<br>(&lt;http://www.franz.com/tutorial#book6&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, &lt;http://www.franz.com/tutorial#author1&gt;)<br><br>(&lt;http://www.franz.com/tutorial#author1&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://xmlns.com/foaf/0.1/Person&gt;)<br>(&lt;http://www.franz.com/tutorial#author1&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;Jack London&quot;)</pre>
<p>There is only one way to simplify the example from here. Perhaps you really don't need author resources at all. It could be sufficient to know the name of a book's author and never reify the author as a node in the graph. In that case, you can pare down the resource descriptions by including the author name as a literal string:</p>
<pre  class="input">  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book3&quot;&gt;<br>    &lt;dc:title&gt;The Call of the Wild&lt;/dc:title&gt;<br>    <strong>&lt;dc:creator&gt;Jack London&lt;/dc:creator&gt;</strong><br>  &lt;/rdf:Description&gt;<br>  <br>  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/tutorial#book4&quot;&gt;<br>    &lt;dc:title&gt;White Fang&lt;/dc:title&gt;<br>    <strong>&lt;dc:creator&gt;Jack London&lt;/dc:creator&gt;</strong><br>  &lt;/rdf:Description&gt;   
</pre>
<p>This example generates only four triples, none of which are duplicates. We have two books, and no author resource. </p>
<pre class="output" >Two books, with one author as a literal value.<br>Number of results: 4
<br>(&lt;http://www.franz.com/tutorial#book3&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;The Call of the Wild&quot;)<br>(&lt;http://www.franz.com/tutorial#book3&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, &quot;Jack London&quot;)<br><br>(&lt;http://www.franz.com/tutorial#book4&gt;, &lt;http://purl.org/dc/elements/1.1/title&gt;, &quot;White Fang&quot;)<br>(&lt;http://www.franz.com/tutorial#book4&gt;, &lt;http://purl.org/dc/elements/1.1/creator&gt;, &quot;Jack London&quot;)</pre>
<p>The lesson here is to keep the representation simple. The fewer resources there are, the faster everything will work. </p>
<h3>Don't Create Duplicate Triples</h3>
<p>Now we'll consider the situation where we have multiple copies of the same information in the triple store. This is the classic &quot;duplicate triples&quot; situation. </p>
<p>True duplicate triples do not occur by accident. They occur only when you have loaded the same information into the triple store more than once. </p>
<p>This is easy to demonstrate. Let's load the Kennedy graph into an empty triple store:</p>
<pre class="output">Load 1214 python-kennedy.ntriples.
After loading, there are:
  1214 kennedy triples in context 'null';</pre>
<p>Then just load the same file again:</p>
<pre class="output">Reload 1214 python-kennedy.ntriples.
After loading, there are:
  2428 kennedy triples in context 'null';</pre>
<p>Now there are two copies of every Kennedy triple. If you add the same triple multiple times, you will get multiple copies of it. </p>
<h3></h3>
<h3>Filter Out Duplicate Results </h3>
<p>In practice, our advice &quot;don't create duplicate triples&quot; may be difficult to follow. Some data feeds contain duplicated information and there is no convenient or efficient way to filter it out. So now you have duplicated data in the system. How much trouble might that cause?</p>
<p>This simple query should return three matches, one for each of Ted Kennedy's three children: </p>
<pre class="input">    SELECT ?o WHERE {kdy:person17 kdy:has-child ?o}</pre>
<p>However, because each of the expected triples has a duplicate, we get six answers instead of three: </p>
<pre class="output">SPARQL matches for children of Ted Kennedy.<br>&lt;http://www.franz.com/simple#person72&gt;<br>&lt;http://www.franz.com/simple#person74&gt;<br>&lt;http://www.franz.com/simple#person76&gt;<br>&lt;http://www.franz.com/simple#person72&gt;<br>&lt;http://www.franz.com/simple#person74&gt;<br>&lt;http://www.franz.com/simple#person76&gt;</pre>
<p>That's a nuisance, but SPARQL provides an easy way to wipe out the duplicate answers: </p>
<pre class="input">    SELECT DISTINCT ?o WHERE {kdy:person17 kdy:has-child ?o}</pre>
<p>The DISTINCT operator does not remove duplicate triples, but it detects and eliminates duplicate variable bindings in the query's output. The duplicate triples are still there in the triple store, but we don't see them in the output:</p>
<pre class="output">SPARQL DISTINCT matches for children of Ted Kennedy.<br>&lt;http://www.franz.com/simple#person72&gt;<br>&lt;http://www.franz.com/simple#person76&gt;<br>&lt;http://www.franz.com/simple#person74&gt;</pre>
<p>DISTINCT works by sorting the bindings by each of the bound variables in the result. This forces duplicate results to be adjacent to each other in the result list. Then it runs over the list and eliminates bindings that are the same as the previous binding. As you can imagine, there are situations where forcing an exhaustive sort on a large binding set might use up a lot of time. </p>
<p>For this reason, SPARQL also offers a REDUCED operator:</p>
<pre class="input">    SELECT REDUCED ?o WHERE {kdy:person17 kdy:has-child ?o} ORDER BY ?o</pre>
<p>REDUCED performs the same sweep for duplicates that DISTINCT performs, but it lets you control the sorting. In this example the values of the subject and predicate are fixed, so sorting by the object value is sufficient to force all duplicate bindings into contact with each other. REDUCED is often much faster than DISTINCT.</p>
<h3>Filtering Duplicate Triples while Loading </h3>
<p>AllegroGraph could check each incoming triple to see if that information is already present in the triple store, but this process would be very time-consuming, slowing down our extremely-fast <a href="http://www.franz.com/agraph/allegrograph/">load times</a> by orders of magnitude. Loading speed is important to almost everyone, so AllegroGraph does not filter duplicates during the load. </p>
<p>If loading speed isn't critical in your application, you can add triples one at a time while checking for duplicates as shown here:</p>
<pre class="input">    if conn.getStatements(newParent, hasChild, newChild):<br>        print &quot;Did not add new triple.&quot;<br>    else:<br>        conn.add(newParent, hasChild, newChild)<br>        print &quot;Added new triple.&quot; </pre>
<p>If <strong>getStatements()</strong> return any value, then the new triple is already present in the store. If not, then we can add it to the store knowing that it will be unique. </p>
<p>When you run this example twice it adds a triple the first time, but not the second time:</p>
<pre class="output">Test before adding triple, first trial: 
Added new triple.  


Test before adding triple, second trial: 
Did not add new triple.</pre>
<h3>Duplicates in Federated Stores</h3>
<p>A <a href="#Federated Repositories">federated store</a> is a single connection to multiple AllegroGraph repositories, possibly on multiple servers at multiple sites. Such systems can have duplicate triples, but deleting them is unwise.</p>
<p>Presumably any existing repository has a purpose of its own, and has been federated with other respositories to serve some combined purpose. It would be a mistake to delete triples from one repository simply because they also occur elsewhere in the federated store. This could damage the integrity of the individual repositories when they are used in stand-alone mode. By similar reasoning, it is a mistake to add triples to a federated repository. Which repository gets the new triples? </p>
<p>For all of these reasons, federated stores are &quot;read only&quot; in AllegroGraph. Attempting to add or delete triples in a federated system result in error messages. </p>
<p>Federation changes the semantics of &quot;duplicate triples.&quot; Be sure to take this into account in your project design. </p>

</body>
</html>
